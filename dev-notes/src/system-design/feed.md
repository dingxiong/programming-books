# Feed & Timeline System

## Design news feed in Twitter

- create post
- follow/unfollow people
- view Feed Timeline

### Traffic estimation

This part is generated by chatgpt.

Basic assumptions.

- Total users: 500 million
- Daily Active Users (DAU): 40% → 200 million
- Tweets per active user per day: 2
- Timeline reads per active user per day: 30
- Average followers per user: 200

Daily tweets are `400M` tweets/day, that is `4,600` tweets/sec. If we assume
the peak is 5x, then we should support `23k` tweets/sec.

For read, `200M × 30 = 6B` reads/day. Peak read is `6B/86400 * 5 = 350k`
reads/sec. So read is 10x of write. Twitter is definitely a read heavy
platform.

### How does feed timeline work?

We have `user`, `follower` and `post` tables. We can simply join these three
table to obtain the timeline view a single user. This is called pull mode. The
problem with this approach is that if a user follows too many other people,
then this query will be very slow.

On the other hand, we can cache or materialize this query, and asynchronously
update it whenever there is a new post or post update. This is called push
mode. There are two problem with this approach.

1. The flow is asynchronous. It only guarantee eventual consistency. Think
   about a scenario that two friends sit together who follow the same celerity.
   One can see the latest post. One cannot.
2. The problem with this approach is that if one user has way many followers
   then the write fans out too many.

A better idea is to combine both approaches, i.e., a hybrid approach. The
`user` table could have a field `celerity` or `is_hot`. We use pull mode to
fetch posts from hot followees and use push mode to fetch posts from non-hot
followees, then combine the two sets.

What storage should we choose for the timeline view cache. Redis is good enough
because Redis cluster supports key partition. It can scale.

Do we need to store post content directly in DB or S3? Most likely DB is
enough. For example, Postgres has Toast optimization. If we really care about
the database size, we can use S3 then.

How to paginate feed page? Use `(timestamp, post_id)` as pagination cursor.
Timestamp pagination is easiest even we need combine two sources of posts. We
can roughly think timestamp is globally incremental primary key. The `post_id`
is used to break ties, so there is no blur boarder.

### Multimedia support

Media is uploaded directly to S3 using pre-signed URLs. We need a `attachment`
table because `post` and `attachment` is a one-2-many relation.
