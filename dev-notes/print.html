<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Life as a Programmer</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/code-details-6df1f091.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-9e4b3991.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-183911b0.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Life as a Programmer</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book contains all I know as a software engineer. From the content you can
see how miserable it is!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="security"><a class="header" href="#security">Security</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tls"><a class="header" href="#tls">TLS</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mtls"><a class="header" href="#mtls">mTLS</a></h1>
<h2 id="encrypted-private-key"><a class="header" href="#encrypted-private-key">Encrypted private key</a></h2>
<pre><code class="language-bash">openssl rsa -in encrypted-private-key.pem -out decrypted-private-key.pem \
-passin file:passphrase.txt
</code></pre>
<h2 id="mtls-support-in-curl"><a class="header" href="#mtls-support-in-curl">mTLS support in <code>curl</code></a></h2>
<p>To specify client’s certificate, we should do as follows,</p>
<pre><code class="language-bash">curl ... \
--key &lt;private-key-file&gt; \
--cert &lt;client-certificate-file&gt; \
--pass &lt;plain-text-passphrase&gt;
</code></pre>
<p>First, note that private key and certificate are passed in as file name, but
passphrase is passed in as plain text. You can tell the difference from
<code>curl</code>’s cmd line
<a href="https://github.com/curl/curl/blob/425a2aa1af0fec9ab41fcc1bcb316b623cebccc7/src/tool_getparam.c#L2216">option parsing logic</a>
and
<a href="https://github.com/curl/curl/blob/425a2aa1af0fec9ab41fcc1bcb316b623cebccc7/lib/urldata.h#L276">ssl config</a>.
Why? This is because internally, curl does not do TLS by itself. All work is
delegate to Openssl. See
<a href="https://github.com/curl/curl/blob/425a2aa1af0fec9ab41fcc1bcb316b623cebccc7/lib/vtls/openssl.c#L1546">code</a>.
Openssl’s C interface just works this way. It takes private key and certificate
file name, but passphrase as string value in its APIs.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="all-i-know-about-c"><a class="header" href="#all-i-know-about-c">All I know about C++</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="c-standards"><a class="header" href="#c-standards">C++ Standards</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="9-declarations"><a class="header" href="#9-declarations">9 Declarations</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="initializers"><a class="header" href="#initializers">Initializers</a></h1>
<p>Initialization in C++ is complicated. See
<a href="https://eel.is/c++draft/dcl.init">C++ standard</a>. If you believe you are an
expert in this area, then please answer the below questions.</p>
<ol>
<li>For <code>int arr[5];</code>, are all 5 elements initialized to zero?</li>
<li>How about <code>int arr[5] = {};</code>?</li>
<li>How about <code>int arr[5] = {1};</code>?</li>
<li>For <code>vector&lt;int&gt; v(5);</code>, are all 5 elements initialized to zero?</li>
<li>How about <code>vector&lt;pair&lt;int, int&gt;&gt; v(5);</code>?</li>
<li>How about <code>array&lt;int, 3&gt; a;</code> and <code>vector&lt;array&lt;int, 3&gt;&gt; v(5);</code>?</li>
</ol>
<p>We need to cover at least concepts: <code>default initialization</code>,
<code>zero initialization</code> and <code>value initialization</code>.</p>
<h2 id="value-initialization"><a class="header" href="#value-initialization">Value Initialization</a></h2>
<p><a href="https://eel.is/c++draft/dcl.init#general-9">dcl.init#general-9</a> covers value
initialization. It covers 3 cases: class type, array type and others.</p>
<h3 id="others"><a class="header" href="#others">Others</a></h3>
<p>Let’s see the others’ case. The standard draft says</p>
<blockquote>
<p>Otherwise, the object is zero-initialized.</p>
</blockquote>
<p>Also, the zero initialization sections says</p>
<blockquote>
<p>if T is any other scalar type, the object is initialized to the value
obtained by converting the integer literal 0 (zero) to T;</p>
</blockquote>
<p>So for <code>int</code>, <code>float</code> etc. value initialization means setting to zero. For
example, <code>float x {};</code> explicitly sets <code>x</code> to <code>0</code>. While <code>float x;</code> is default
initialization. How is a primitive default initialized? Section <code>general-7.4</code>
says no initialization is performed, which mean it is random, i.e., any garbage
value at that stack location.</p>
<p>So remember: <strong>scalar type value-initialization is zero-initialization</strong>.</p>
<h3 id="class-type"><a class="header" href="#class-type">Class type</a></h3>
<p>If <code>T</code> is a class type, and if it has a user-provided constructor, then it this
constructor is used. If no such constructor, then it is zero initialized.
<strong>After that, the object is then default initialized.</strong></p>
<p>For example, a simple class as below</p>
<pre><code class="language-cpp">struct A {
  int x, y;
  A(int y): y(y) {}
};

A a(5);
</code></pre>
<p>It has a user-provided constructor. It is first called, so <code>y</code> is initialized
to <code>5</code>. How about <code>x</code>? It is default initialized and thus a random value. If we
change <code>int x, y;</code> to <code>int x = 0; int y;</code>, then it is default to zero.</p>
<p>Let’s see another case <code>vecotr&lt;int&gt; v(5);</code>. The vector self is
value-initialized. How about its elements? cppconference.com says “Constructs a
vector with count default-inserted objects of T. No copies are made.” What does
<code>default-inserted</code> means? The standard section
<a href="https://eel.is/c++draft/container.requirements#container.alloc.reqmts-2.2">container.requirements#container.alloc.reqmts-2.2</a>
says</p>
<pre><code>An element of X is default-inserted if it is initialized by evaluation of the
expression `allocator_traits&lt;A&gt;::construct(m, p)`.
</code></pre>
<p>I checked the libc++ implementation. The final piece is this
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__memory/construct_at.h#L38">construct_at</a>
function. It basically says</p>
<pre><code>return ::new (static_cast&lt;void*&gt;(__location)) _Tp(std::forward&lt;_Args&gt;(__args)...);
</code></pre>
<p>For this vector example, <code>__args</code> is empty, thus it is simplified to
<code>::new int();</code>. You can test it out<sup class="footnote-reference" id="fr-note1-1"><a href="#footnote-note1">1</a></sup>, this is value initialization!
Therefore, <code>vector&lt;int&gt; v(5);</code> initializes all elements to zero.</p>
<h4 id="why-is-new-t-value-initialized"><a class="header" href="#why-is-new-t-value-initialized">Why is <code>new T(...)</code> value initialized?</a></h4>
<p>Let’s present the result first:</p>
<ul>
<li><code>new T()</code> → value initialization (zeros for primitive types).</li>
<li><code>new T</code> → default initialization (indeterminate for primitive types).</li>
</ul>
<p><a href="https://eel.is/c++draft/dcl.init#general-16.4">dcl.init#general-16.4</a> says “If
the initializer is (), the object is value-initialized.” But <code>()</code> cannot be
used as initializer in most cases. The few exceptions include the <code>new</code>
operator. Then <a href="https://eel.is/c++draft/expr.new#24">expr.new#24</a> says “If the
new-initializer is omitted, the object is default-initialized. Otherwise, the
new-initializer is interpreted according to the initialization rules of
[dcl.init] for direct-initialization.” So it makes a huge difference if there
is <code>()</code> or not in the <code>new</code> expression.</p>
<p>Not just for <code>int</code>, it applies to <code>vector&lt;pair&lt;int, int&gt;&gt;</code> and
<code>vector&lt;tuple&lt;int, float&gt;&gt;</code> as well. The default constructor of <code>pair</code> and
<code>tuple</code> both value-initializes all elements. It is explicitly written in
cppconference.com. Similar goes with <code>vector&lt;array&lt;int, N&gt;&gt;</code>. The values are
all zero.</p>
<h3 id="array-type"><a class="header" href="#array-type">Array type.</a></h3>
<p>Lastly, if <code>T</code> is an array type, then all its elements are value initialized.
Let’s analyze three cases:</p>
<ul>
<li><code>int arr[5];</code>: default initialization. These 5 elements are random.</li>
<li><code>int arr[5] = {};</code>: value initialization. Each element is value initialized.
As said above, each one is zero-initialized. So this is equivalent to
<code>int arr[5] = {0, 0, 0, 0, 0};</code>;</li>
<li><code>int arr[5] = {1, 2};</code>: value initialization.
<a href="https://eel.is/c++draft/dcl.init#general-16.5">dcl.init#general-16.5</a> has a
special paragraph for this case. Basically, element <code>e_i</code> is copy initialized
for <code>1 &lt;= i &lt;= k</code> and remaining elements are value-initialized. so this is
equivalent to <code>int arr[5] = {1, 2, 0, 0, 0};</code>.</li>
</ul>
<h2 id="answers-to-the-questions-at-the-beginning"><a class="header" href="#answers-to-the-questions-at-the-beginning">Answers to the questions at the beginning.</a></h2>
<ol>
<li>No. The elements are random because <code>arr</code> is default initialized.</li>
<li>Yes. All zeros because <code>arr</code> is value initialized.</li>
<li>The first element is <code>1</code>. The rest is <code>0</code>.</li>
<li>Yes. All zeros;</li>
<li>Yes. All pairs have zero first and zero second parts.</li>
<li><code>array&lt;int, 3&gt; a;</code> has random values. <code>vector&lt;array&lt;int, 3&gt;&gt; v(5);</code> are all
initialized to zero.</li>
</ol>
<hr>
<ol class="footnote-definition">
<li id="footnote-note1">
<p>Please do exactly as <code>int *p = new int();</code> because <code>int a();</code> won’t give
what you want. Checkout “most vexing parse”. <a href="#fr-note1-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="abbreviated-function-template"><a class="header" href="#abbreviated-function-template">Abbreviated function template</a></h1>
<p>C++20 introduced a new syntax
<a href="https://en.cppreference.com/w/cpp/language/function_template.html">Abbreviated function template</a>.
The proposal is <code>P1141R2</code>. <a href="https://eel.is/c%2B%2Bdraft/dcl.fct#21">dcl.fct#21</a>
provides some good examples. Basically, when you write a function parameter as
auto, the compiler automatically generates a template.</p>
<p>TODO: write more details about LLVM implementation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="template"><a class="header" href="#template">Template</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ctad-class-template-argument-deduction"><a class="header" href="#ctad-class-template-argument-deduction">CTAD (Class template argument deduction)</a></h1>
<h2 id="greater"><a class="header" href="#greater">greater&lt;&gt;</a></h2>
<p>Many times, you can omit the type parameter in functional operators such as
<code>std::greater&lt;&gt;</code>. This is a new feature of C++14. See the implementation of
<code>std::greater</code>
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__functional/operations.h#L447">code1</a>
and
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__functional/operations.h#L460">code2</a>
for example. The trick is simple: the template parameter has a default <code>void</code>
value, and the void specialization perfectly forwards all arguments are
perfectly forward all arguments to <code>operator()(...)</code>.</p>
<p>See <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3421.htm">n3421</a>
for the motivation and why choosing this approach.</p>
<h2 id="vector-v"><a class="header" href="#vector-v">vector v;</a></h2>
<p>We do not need to write boilerplate code like
<code>vector&lt;vector&lt;int&gt;&gt; v(5, vector&lt;int&gt;(6));</code> any more. In C++17, we can simply
write <code>vector v(5, vector&lt;int&gt;(6));</code> Thanks to
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r3.html">P0091R3: Template argument deduction for class templates</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="competitive-programming"><a href="#competitive-programming" class="header">Competitive Programming</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="comparator"><a class="header" href="#comparator">Comparator</a></h1>
<p><code>std::sort</code> can pass a <code>comp</code> parameter at the end. If not specified, then it
is defaults to
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/sort.h#L967">std::less</a>.</p>
<p>Sometimes, we want to sort nested containers, then how comparison works for
them.</p>
<p>For vector, it is defined as
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__vector/comparison.h#L49">std::lexicographical_compare</a>.
Basically, it compares element by element until a different one is found or one
vector goes out of range. In the latter case, the short vector is smaller.
<code>std:string</code>, <code>std::deque</code>, <code>std::array</code> <code>std::pair</code> and <code>std::tuple</code> are
similar to vector. They compare from the first element. If equal, then the
second, and the rest.</p>
<p><code>std::set</code> and <code>set::map</code> define <code>operator&lt;</code> as well. It is lexicographical
order as well. However, <code>std::unordered_set</code> and <code>std::unordered_map</code> only
define <code>operator==</code> and <code>operator!=</code>.</p>
<p>Comparator is also used extensively in sorted containers. <code>std::set</code> and
<code>std::map</code> has comparator template argument. There is a caveat that</p>
<blockquote>
<p>Everywhere the standard library uses the Compare requirements, uniqueness is
determined by using the equivalence relation. In imprecise terms, two objects
a and b are considered equivalent if neither compares less than the other:
!comp(a, b) &amp;&amp; !comp(b, a).</p>
</blockquote>
<p>The concrete code is
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__tree#L1705">here</a>.
Both <code>set</code> and <code>map</code> are implemented using red-black tree. When inserting a new
element, The case <code>not a &lt; b and not b &lt; a</code> means two keys are equal. If you
forget tie breaker, then you may end up with a undetermined behavior. For
example, in Dijkstra shortest path algorithm, we should define the comparator
as</p>
<pre><code class="language-cpp">auto comp = [&amp;distances](const string &amp;a, const string &amp;b) {
    if (distances[a] != distances[b])
        return distances[a] &lt; distances[b];
    return a &lt; b;
};
</code></pre>
<h1 id="radix-sort"><a class="header" href="#radix-sort">Radix Sort</a></h1>
<p>libc++ has a good demonstration of the usage of radix sort. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/stable_sort.h#L256">code</a>.</p>
<p>First, it is only used if the container value type is integral. It works for
int32, int64, etc but not floats, strings. Also, it supports negative integrals
as well. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/radix_sort.h#L298">code</a>.
Using int8 as an example, the trick <code>numeric_limits&lt;_Ip&gt;::min() ^ value</code> can be
explained by below table.</p>
<pre><code>┌───────────────────┬───────────────────────┬──────────────────────────┬───────────────────┐
│ Original (Signed) │ Binary Representation │ XOR with -128 (10000000) │ Result (Unsigned) │
├───────────────────┼───────────────────────┼──────────────────────────┼───────────────────┤
│ -128              │ 10000000              │ 10000000 ^ 10000000      │ 00000000 (0)      │
│ -127              │ 10000001              │ 10000001 ^ 10000000      │ 00000001 (1)      │
│ -1                │ 11111111              │ 11111111 ^ 10000000      │ 01111111 (127)    │
│ 0                 │ 00000000              │ 00000000 ^ 10000000      │ 10000000 (128)    │
│ 1                 │ 00000001              │ 00000001 ^ 10000000      │ 10000001 (129)    │
│ 127               │ 01111111              │ 01111111 ^ 10000000      │ 11111111 (255)    │
└───────────────────┴───────────────────────┴──────────────────────────┴───────────────────┘
</code></pre>
<p>It maps <code>[-128, 127]</code> to <code>[0, 255]</code> without changing the relative order.</p>
<p>Second, in the competitive coding context, most people will do radix sorting by
comparing the decimal digits, but libc++
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/radix_sort.h#L306">compares bytes</a>.</p>
<p>Third, radix sorting uses counting sort. The basic idea is counting the digit
occurrence and do a prefix sum, so we know the position in the sorted array
given a digit. The caveat is to maintain the stable order. If two numbers have
the same digit, their relative order should not change. The pseudocode is</p>
<pre><code class="language-cpp">void counting_sort(vector&lt;int&gt;&amp; arr, int exp) {
    int n = arr.size();
    vector&lt;int&gt; output(n), count(10, 0);

    // frequency prefix sum.
    for (int i = 0; i &lt; n; i++) count[(arr[i] / exp) % 10]++;
    for (int i = 1; i &lt; 10; i++) count[i] += count[i - 1];

    // start from the right end and decrease the frequency so we can maintain
    // stable order.
    for (int i = n - 1; i &gt;= 0; i--) {
        int digit = (arr[i] / exp) % 10;
        output[count[digit] - 1] = arr[i];
        count[digit]--;
    }
    arr = output;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="priority-queue"><a class="header" href="#priority-queue">Priority Queue</a></h1>
<p>I do not like <code>std::priority_queue</code> because it does not provide the <code>begin</code> nor
<code>end</code> iterator. Later on, I learned a set of functions to deal with max heap
directly: <code>make_heap</code>, <code>push_heap</code> and <code>pop_heap</code>. I am very happy with it
because it allows me implementing priority queue on top of vector, and I can
iterate vector! Then I suspect the push/pop operation of <code>std::priority_queue</code>
is just a wrapper of <code>push_heap</code>/<code>pop_heap</code>. It is! See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/queue#L899">code</a>.</p>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<p>A few examples.</p>
<pre><code class="language-cpp">priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; pq;
</code></pre>
<pre><code class="language-cpp">auto comp = std::greater&lt;int&gt;{};
priority_queue&lt;int, std::vector&lt;int&gt;, decltype(comp)&gt; pq(comp);
</code></pre>
<pre><code class="language-cpp">vector v = {1, 2, 3, 5};
priority_queue&lt;int&gt; pq(v.begin(), v.end());
</code></pre>
<p>Just want to point out the last constructor has time complexity <code>O(N)</code>, not
<code>O(NlogN)</code>. Underneath, it just calls
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/queue#L786">std::make_heap</a>.</p>
<h2 id="heap"><a class="header" href="#heap">Heap</a></h2>
<p>What is a max heap?</p>
<ol>
<li>
<p>A heap must be a complete binary tree, meaning all levels are fully filled
except possibly the last level, which fills from left to right. If we store
it in an array <code>arr</code> with <code>arr[0]</code> being the root, then left and right of
<code>arr[i]</code> are <code>arr[2*i+1]</code> and <code>arr[2*i+2]</code>.</p>
</li>
<li>
<p>For max heap, every parent node is greater or equal to its children. Min
heap is reverse.</p>
</li>
</ol>
<p>The bottom-up heapify process takes <code>O(N)</code> steps.</p>
<pre><code class="language-cpp">void heapify_down(vector&lt;int&gt;&amp; a, int n, int i) {
    int mx = i, l = 2*i + 1, r = 2*i + 2;
    if (l &lt; n &amp;&amp; a[l] &gt; a[mx]) mx = l;
    if (r &lt; n &amp;&amp; a[r] &gt; a[mx]) mx = r;
    if (mx != i) {
        swap(a[i], a[mx]);
        heapify_down(a, n, mx);
    }
}

// Build max heap - O(n)
void make_heap(vector&lt;int&gt;&amp; a) {
    for (int i = a.size()/2 - 1; i &gt;= 0; i--)
        heapify_down(a, a.size(), i);
}

// Insert element at end and heapify up - O(log n)
void push_heap(vector&lt;int&gt;&amp; a) {
    int i = a.size() - 1;
    while (i &gt; 0 &amp;&amp; a[(i-1)/2] &lt; a[i]) { // parent at index (i-1)/2
        swap(a[i], a[(i-1)/2]);
        i = (i-1)/2;
    }
}

// Remove max (root), move last to root, heapify down - O(log n)
void pop_heap(vector&lt;int&gt;&amp; a) {
    swap(a[0], a[a.size()-1]);
    heapify_down(a, a.size()-1, 0);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tree-graph"><a class="header" href="#tree-graph">Tree, Graph</a></h1>
<p>A tree is an undirected, connected, and acyclic graph. It has <code>n</code> nodes, <code>n-1</code>
edges and is fully connected. This setup often shows up in competitive
programming.</p>
<p>Realizing it is a tree is helpful for DFS because often times the graph
definition contains not only the child nodes but also the parent node. A simple
trick to skip going back is</p>
<pre><code class="language-cpp">for (next : graph[node]):
    if (next == parent_node) continue
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="segment-tree"><a class="header" href="#segment-tree">Segment Tree</a></h1>
<p>A segment tree is a binary tree data structure used to efficiently answer range
queries and perform range updates on an array — such as:</p>
<ul>
<li>Range sum</li>
<li>Range minimum/maximum</li>
<li>Range gcd, etc.</li>
</ul>
<p>It’s designed to balance query speed and update speed, both in O(log N) time.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>A few conventions to reduce chances of mistakes.</p>
<ol>
<li>left branch is <code>[l, m]</code>, right branch is <code>[m+1, r]</code>. This avoids the index
of out of range error for the middle point <code>(l+r)/2</code>.</li>
</ol>
<p>Below is the naive implementation using explicit tree node.</p>
<details class="code-details">
<summary> struct Node; </summary>
<pre><code class="language-cpp">struct Node {
    int l, r;
    shared_ptr&lt;Node&gt; left, right;
    int s; // each node stores the sum of the range [l,r].
    Node(int l, int r): l(l), r(r), s(0) {}
};
using NodeP = shared_ptr&lt;Node&gt;;

NodeP root;

void create_children(NodeP node) {
     if (node-&gt;l != node-&gt;r) {
        int m = (node-&gt;l + node-&gt;r) / 2;
        if (not node-&gt;left) node-&gt;left = make_shared&lt;Node&gt;(node-&gt;l, m);
        if (not node-&gt;right) node-&gt;right = make_shared&lt;Node&gt;(m+1, node-&gt;r);
    }
}

int query(NodeP node, int l, int r) {
    int m = (node-&gt;l + node-&gt;r) / 2;
    create_children(node);
    if (node-&gt;l == l and node-&gt;r == r) {
        return node-&gt;s;
    }

    if (r &lt;= m) return search(node-&gt;left, l, r);
    else if (l &gt; m) return search(node-&gt;right, l, r);
    else return search(node-&gt;left, l, m) + search(node-&gt;right, m+1, r);
}

// Add val to the existing value at node i.
void update(NodeP node, int i, int val) {
  create_children();
  node-&gt;s += val;
  if (node-&gt;l == i and node-&gt;r == i) return;
  int m = (node-&gt;l + node-&gt;r) / 2;
  if (i &lt;= m) update(node-&gt;left, i, val);
  else update(node-&gt;right, i, val);
}
</code></pre>
</details>
<p>Most segment tree code you see online uses an array to represent the tree. See
<a href="https://www.hackerearth.com/practice/notes/segment-tree-and-lazy-propagation/">example</a>.
An array <code>int tree[2n+1]</code> represent a tree with <code>n</code> nodes. <code>tree[k]</code> has
children <code>tree[2k]</code> and <code>tree[2k+1]</code>. Root node is <code>tree[1]</code>. However, I do not
like this implementation because it makes the interface more verbose. In my
implementation, <code>struct Node</code> contains the boundary information <code>l</code> and <code>r</code>.
With the array approach, the interface becomes
<code>int query(int node, int start, int end, int l, int r)</code>. The first 3 parameters
are the node index, left and right boundary.</p>
<h2 id="lazy-propagation"><a class="header" href="#lazy-propagation">Lazy Propagation</a></h2>
<p>The basic search and update operation has <code>O(logN)</code> complexity. It is not
efficient for range update. To make it <code>O(logN)</code> as well, we need lazy
propagation. A new helper <code>push</code> introduced. It realized the laziness at the
current node, and push the laziness down to its children. There are four places
we need <code>push</code>. First, at the beginning of a query, which is obvious. Then 3
places in <code>update</code>:</p>
<ol>
<li>At the beginning of <code>update</code>.</li>
<li>At the base condition, i.e., query range equals node’s boundary. This is
where the performance improvement comes from. It avoids going deep to leaf
nodes, and simply put a marker in the current node saying: all nodes under
this subtree have an un-realized update amount <code>inc_amount</code>.</li>
<li>Before we finally update current node’s value. This is pre-order traversal.
We need to make sure the left and right children do not have any lazy value
before we add them up. Otherwise, it would be wrong. This is most popular
mistake I made!</li>
</ol>
<details class="code-details">
<summary> Lazy Propagation </summary>
<pre><code class="language-cpp">struct Node {
    int l, r;
    shared_ptr&lt;Node&gt; left, right;
    int lazy = 0; // lazy update amount
    int s;
    Node(int l, int r): l(l), r(r), s(0) {}
};
using NodeP = shared_ptr&lt;Node&gt;;

NodeP root;

void create_children(NodeP node) {
     if (node-&gt;l != node-&gt;r) {
        int m = (node-&gt;l + node-&gt;r) / 2;
        if (not node-&gt;left) node-&gt;left = make_shared&lt;Node&gt;(node-&gt;l, m);
        if (not node-&gt;right) node-&gt;right = make_shared&lt;Node&gt;(m+1, node-&gt;r);
    }
}

// realize laziness at current node and push it down the tree.
void push(NodeP node) {
    if (node-&gt;lazy) {
        node-&gt;s += node-&gt;lazy * (node-&gt;r - node-&gt;l + 1);
        // only push down when it is not a leaf node.
        if (node-&gt;l != node-&gt;r) {
            node-&gt;left-&gt;lazy += node-&gt;lazy;
            node-&gt;right-&gt;lazy += node-&gt;lazy;
        }
        // remember to reset laziness.
        node-&gt;lazy = 0;
    }
}

int query(NodeP node, int l, int r) {
    int m = (node-&gt;l + node-&gt;r) / 2;
    create_children(node);
    // realize laziness before query.
    push(node);
    if (node-&gt;l == l and node-&gt;r == r) {
        return node-&gt;s;
    }

    if (r &lt;= m) return search(node-&gt;left, l, r);
    else if (l &gt; m) return search(node-&gt;right, l, r);
    else return search(node-&gt;left, l, m) + search(node-&gt;right, m+1, r);
}

void update(NodeP node, int l, int r, int inc_amount) {
    int m = (node-&gt;l + node-&gt;r) / 2;
    create_children(node);
    push(node);

    if (node-&gt;l == l and node-&gt;r == r) {
        node-&gt;lazy += inc_amount;
        push(node);
        return;
    }
    if (r &lt;= m) {
        update(node-&gt;left, l, r);
    } else if (l &gt; m) {
        update(node-&gt;right, l, r);
    } else {
        update(node-&gt;left, l, m);
        update(node-&gt;right, m+1, r);
    }
    // make sure left and right do not have un-realized updates.
    push(node-&gt;left); push(node-&gt;right);
    node-&gt;s = node-&gt;left-&gt;s + node-&gt;right-&gt;s;
}
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fenwick-tree"><a class="header" href="#fenwick-tree">Fenwick Tree</a></h1>
<p>A Fenwick tree (also called a Binary Indexed Tree or BIT) is a data structure
that efficiently supports two operations on an array:</p>
<ul>
<li>Update: Modify a single element</li>
<li>Prefix sum query: Calculate the sum of elements from index 0 to any given
index</li>
</ul>
<p>Both operations run in <code>O(log n)</code> time. So the difference between BIT and
segment tree is that the latter can define different aggregation; while the
former is only for prefix sum query. See the “Policy-Based Data Structures”
post about which to choose.</p>
<h2 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h2>
<p>The key insight is that any number can be represented as a sum of powers of 2.
The Fenwick tree stores partial sums in a clever way where:</p>
<ul>
<li>Each index is responsible for a range of elements.</li>
<li>The range size is determined by the lowest set bit in the index.</li>
</ul>
<p>Index <code>2^k</code> stores sum of index <code>2^{k-1} + 1</code>, <code>2^{k-1} + 2</code>, … <code>2^k</code>. Note
index starts from <code>1</code> not <code>0</code>. For example, in a Fenwick tree:</p>
<ul>
<li>Index 1 (binary: 001) stores sum of 1 elements: <code>001</code>.</li>
<li>Index 4 (binary: 100) stores sum of 4 elements: <code>001</code>, <code>010</code>, <code>011</code>, <code>100</code></li>
<li>Index 6 (binary: 110) stores sum of 2 elements: <code>110</code>, <code>101</code>.</li>
</ul>
<p>From this we can see given an index <code>i</code>, it must be responsible for the value
at index itself. Then we change the lowest set bit to zero, and sums up all
indices with combinations of the lower bits.</p>
<pre><code class="language-cpp">struct FenwickTree {
    vector&lt;int&gt; bit;
    int n;

    // bit starts from index 1.
    FenwickTree(int n) : n(n), bit(n + 1) {}

    void update(int i, int delta) {
        // why ++i? Indices are 1-indexed internally.
        for (++i; i &lt;= n; i += i &amp; -i)
            bit[i] += delta;
    }

    int query(int i) {
        int sum = 0;
        for (++i; i &gt; 0; i -= i &amp; -i)
            sum += bit[i];
        return sum;
    }

    int rangeQuery(int l, int r) {
        return query(r) - (l ? query(l - 1) : 0);
    }
};
</code></pre>
<p>The trick <code>i &amp; -i</code> isolates the lowest set bit.</p>
<ul>
<li><code>i + (i &amp; -i)</code>: jump to next responsible index.</li>
<li><code>i - (i &amp; -i)</code>: jump to previous range.</li>
</ul>
<p>To be honest, even with so many hints, I find it is still hard to remember this
implementation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="policy-based-data-structures"><a class="header" href="#policy-based-data-structures">Policy-Based Data Structures</a></h1>
<p>Sometimes, we need a data structure that counts the number of integers greater
than a given value x and supports insertion. This mostly happen in a scenario
where you iterate through an array and calculate something for each element and
you would like the overall time complexity to be <code>O(NlogN)</code>. You may think of
using <code>std::set</code> or <code>std::multiset</code> as below.</p>
<pre><code class="language-cpp">std::set&lt;int&gt; s;
auto iter = set.lower_bound(x);
num = std::distance(iter, s.end());
</code></pre>
<p>This won’t work as expected because <code>std::distance</code> has linear time complexity.</p>
<p>In order to make it <code>O(logN)</code>, we need some metadata attached to each tree
node. Support you will design it. What metadata you would attach? The size of
the subtree under each node, right? That is the exact idea of policy-based data
structures.</p>
<p>The most commonly used one is the below <code>pb_set</code> and <code>pb_map</code>. See example
below.</p>
<pre><code class="language-cpp">#include &lt;ext/pb_ds/assoc_container.hpp&gt;
#include &lt;ext/pb_ds/tree_policy.hpp&gt;
using namespace __gnu_pbds;

template&lt;class K&gt;
using pb_set = tree&lt;
    K,                        // key type
    null_type,                // mapped type (null for set)
    std::less&lt;K&gt;,             // comparator
    rb_tree_tag,              // underlying tree = red-black tree
    tree_order_statistics_node_update&gt;; // enables order stats

template&lt;class K, class V&gt;
using pb_map = tree&lt;
    K,
    V,
    std::less&lt;K&gt;,
    rb_tree_tag,
    tree_order_statistics_node_update&gt;;

int main() {
    pb_set&lt;int&gt; s;
    s.insert(1); s.insert(3); s.insert(5);
    for (int i = 0; i &lt;= 6; i++) cout &lt;&lt; s.order_of_key(i) &lt;&lt; endl;
    // output: 0 0 1 1 2 2 3
}
</code></pre>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<p>See the
<a href="https://github.com/gcc-mirror/gcc/blob/35e029530f256bb6302a3cae650d7eaef5514a36/libstdc++-v3/include/ext/pb_ds/tree_policy.hpp#L100">interface description</a>
and the implementation
<a href="https://github.com/gcc-mirror/gcc/blob/35e029530f256bb6302a3cae650d7eaef5514a36/libstdc++-v3/include/ext/pb_ds/detail/tree_policy/order_statistics_imp.hpp#L79">here</a>.
Basically, function <code>order_of_key</code> sums the metadata of all the left nodes of
the current node. The metadata is calculated in the <code>operator()(...)</code> function
which is the count of nodes in the subtree.</p>
<p>So we should expect <code>__gnu_pbds::tree&lt;...&gt;</code> should implement all <code>std::map</code>
methods, such as <code>insert</code>, <code>erase</code> and etc. But when I use it in practice, I
found it does not have <code>emplace(...)</code> method. What the hell! Since this is a
not a standardized container, this is totally possible. I decided to figure out
what interfaces it defines. With AI’s help, I figure out almost all its methods
inherit from
<a href="https://github.com/gcc-mirror/gcc/blob/35e029530f256bb6302a3cae650d7eaef5514a36/libstdc++-v3/include/ext/pb_ds/detail/rb_tree_map_/rb_tree_.hpp#L84">rb_tree_map</a>.
Yes, the base class is determined by the tag you passed in the template.
<code>rb_tree_map</code> is a subclass of
<a href="https://github.com/gcc-mirror/gcc/blob/35e029530f256bb6302a3cae650d7eaef5514a36/libstdc++-v3/include/ext/pb_ds/detail/bin_search_tree_/bin_search_tree_.hpp#L109">bin_search_tree_map</a>.
<code>bin</code> means <code>binary</code>. Make sense. Red-black tree is a binary tree.</p>
<p>From <code>bin_search_tree_map</code>, it gets</p>
<ul>
<li><code>empty()</code></li>
<li><code>size()</code></li>
<li><code>max_size()</code>: Returns the maximum possible number of elements.</li>
<li><code>lower_bound(key)</code></li>
<li><code>upper_bound(key)</code></li>
<li><code>find(key)</code>: Finds an element with a specific key.</li>
<li><code>begin()</code></li>
<li><code>end()</code></li>
<li><code>rbegin()</code></li>
<li><code>rend()</code></li>
<li><code>clear()</code></li>
</ul>
<p>From <code>rb_tree_map</code> (the red-black tree specific operations), it gets</p>
<ul>
<li><code>insert(value)</code></li>
<li><code>operator[](key)</code></li>
<li><code>erase(key)</code> or <code>erase(iterator)</code></li>
<li><code>join(other_tree)</code>: Merges another tree into the current one.</li>
<li><code>split(key, other_tree)</code>: Splits the tree into two based on a key.</li>
</ul>
<p>Unfortunately, pb_ds is only implemented inside GCC/libstdc++. LLVM/libc++ does
not have it.</p>
<h2 id="which-to-choose-segment-tree-fenwick-tree-or-pb-ds"><a class="header" href="#which-to-choose-segment-tree-fenwick-tree-or-pb-ds">Which to choose, Segment Tree, Fenwick tree or PB-DS?</a></h2>
<p>All three options solve the similar problem. The TL;DR recommendations are
summarized in below table.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scenario</th><th>Best Choice</th><th>Why</th></tr>
</thead>
<tbody>
<tr><td>Need <strong>count ≤ X</strong> or <strong>count &gt; X</strong> dynamically with arbitrary inserts</td><td><strong>PBDS</strong></td><td>Easiest, O(log N) both ways</td></tr>
<tr><td>Same need, but on macOS / LLVM (no PBDS)</td><td><strong>Fenwick Tree</strong></td><td>Works anywhere, just compress coordinates</td></tr>
<tr><td>Need <strong>range sums / updates</strong> on numeric ranges</td><td><strong>Segment Tree</strong></td><td>More flexible for numeric aggregations</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="trie"><a class="header" href="#trie">Trie</a></h1>
<p>Trie tree is easy to implement. See below sample code for lower case English
corps.</p>
<pre><code class="language-cpp">struct Node {
  shared_ptr&lt;Node&gt; next[26];
  int val = 0;
  Node() {}
};
using NodeP = shared_ptr&lt;Node&gt;;

NodeP root = make_shared&lt;Node&gt;();

void insert(const string&amp; word) {
  NodeP node = root;
  for (char c: word) {
    int idx = c - 'a';
    if (not node-&gt;next[idx]) node-&gt;next[idx] = make_shared&lt;Node&gt;();
    node = node-&gt;next[idx];
  }
  node-&gt;val = 1;
}
</code></pre>
<h2 id="optimizations"><a class="header" href="#optimizations">Optimizations</a></h2>
<p>The naive explicit tree structure using pointers is not cache friendly. One
optimization is to use an array to represent the tree. The <code>next</code> vector should
store the index of the next node in in the array. This was definitely not
invented by me. Checkout
<a href="https://cp-algorithms.com/string/aho_corasick.html">this reference</a>.</p>
<pre><code class="language-cpp">struct Node {
  int next[26], val = 0;
  Node() { fill_n(next, 26, -1); } // very important to explicitly initialize it.
};

vector&lt;Node&gt; trie(1); // the first element is the root

void insert(const string&amp; word) {
  int node = 0; // root at index 0.
  for (char c: word) {
    int idx = c - 'a';
    if (trie[node].next[idx] == -1) {
      trie[node].next[idx] = trie.size();
      trie.emplace_back(); // push the new node to the end of the array.
    }
    node = trie[node].next[idx];
  }
  trie[node].val = 1;
}
</code></pre>
<p>I asked chatgpt for more optimizations, and it suggests me that use a 2d array
<code>trie[n][next]</code> to go further with cache friendly. Too much for me!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="union-find"><a class="header" href="#union-find">Union-Find</a></h1>
<p>Read below beautiful one-liner implementation of the <code>find</code> function.</p>
<pre><code class="language-cpp">
vector&lt;int&gt; p; // fathers or parents
vector&lt;int&gt; ss; // size of each joint group.

int find(int i) {
    /*
    * If it itself is root, just return. If not, then find its real parent.
    * This part contains path compression because of the recursive call to
    * the `find` function.
    */
    return p[i] == i ? i : p[i] = find(p[i]);
}

void join(int i, int j, int cost) {
    int pi = find(i), pj = find(j);

    // this check is important. Otherwise, it updates group size which is wrong.
    if (pi != pj) {
        // Union by rank optimization - attaches smaller tree under larger one.
        if (ss[i] &gt; ss[j]) swap(pi, pj);
        p[pi] = pj;
        ss[pj] += ss[pi];
    }
}
</code></pre>
<h2 id="applications"><a class="header" href="#applications">Applications</a></h2>
<h3 id="cycle-detection"><a class="header" href="#cycle-detection">Cycle detection</a></h3>
<p>We can make the <code>join</code> function to return a boolean indicating the two nodes
are already joined or not. This trick can detect cycles in a graph.</p>
<h3 id="minimal-spanning-tree"><a class="header" href="#minimal-spanning-tree">Minimal Spanning Tree</a></h3>
<p>A minimum spanning tree (MST) or minimum weight spanning tree is a subset of
the edges of a connected, edge-weighted undirected graph that connects all the
vertices together, without any cycles and with the minimum possible total edge
weight.</p>
<p>Kruskal’s algorithm uses Union-Find algorithm.</p>
<pre><code class="language-cpp">vector&lt;array&lt;int,3&gt;&gt; edges; // {weight, u, v}

// step 1: sort by weight
sort(edges.begin(), edges.end());


// step 2: Try to add each edge in order
// Here, we make a small change to the `join` function. It returns true if
// join happens, false if the two nodes are already joined.
long long mst = 0;
for (auto [w, u, v] : edges) {
    if (join(u, v)) mst += w;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="binary-lifting"><a class="header" href="#binary-lifting">Binary Lifting</a></h1>
<p>Binary lifting is an algorithmic technique primarily used in trees to
efficiently answer queries related to ancestors, such as finding the <code>K-th</code>
ancestor of a node or the Lowest Common Ancestor (LCA) of two nodes. It
leverages dynamic programming and the binary representation of numbers to
achieve logarithmic time complexity for queries after an initial preprocessing
step.</p>
<p>The central idea is to precompute and store the ancestors of each node at
specific powers of two. For a node <code>u</code>, we store its <code>2^0</code>-th ancestor (its
direct parent), its <code>2^1</code>-th ancestor (its grandparent), its <code>2^2</code>-th ancestor,
and so on, up to the <code>2^k</code>-th ancestor where <code>2^k</code> is approximately equal to
the height of the tree. This information is typically stored in a 2D array, say
<code>up[node][k]</code>, which represents the <code>2^k</code>-th ancestor of node.</p>
<p>Use cases:</p>
<ol>
<li>kth ancestor.</li>
<li>Least Common Ancestor (LCA).</li>
<li>Path aggregates using binary lifting.</li>
</ol>
<pre><code class="language-cpp">using vi = vector&lt;int&gt;;

vector&lt;vi&gt; up;
int LOG;

build_power2_ancestors(int n, vector&lt;int&gt;&amp; parent) {
    LOG = ceil(log2(n)) + 1;
    up.resize(LOG, vi(n, -1));

    for (int i = 0; i &lt; n; i++) up[0][i] = parent[i];
    for (int p = 1; p &lt; dep; p++) {
        for (int i = 0; i &lt; n; i++) {
            int a = up[p-1][i];
            if (a == -1) up[p][i] = -1;
            else up[p][i] = up[p-1][a];
        }
    }
}

int kth_ancestor(int node, int k) {
    for (int i = LOG-1; i &gt;= 0; i--) {
        if ((k &amp; (1&lt;&lt;i)) == 0) continue;
        if (i &gt; up.size()-1) return -1;
        node = up[i][node];
        if (node == -1) return -1;
    }
    return node;
}

int lca(int u, int v) {
   // Make u the deeper node
   if (depth[u] &lt; depth[v]) swap(u, v);

   // Bring u to the same level as v
   int diff = depth[u] - depth[v];
   u = kth_ancestor(u, diff);

   // If u and v are the same after leveling
   if (u == v) return u;

   // Binary search for LCA
   for (int j = LOG - 1; j &gt;= 0; j--) {
       if (up[j][u] != up[j][v]) {
           u = up[j][u];
           v = up[j][v];
       }
   }

   return up[0][u];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lower_bound-and-upper_bound"><a class="header" href="#lower_bound-and-upper_bound">lower_bound and upper_bound</a></h1>
<p>These two functions/interfaces are very counter intuitive the first time I read
it. <code>lower_bound</code> means the position that is greater or equal than the target.
<code>upper_bound</code> means the position that is greater than the target. Actually,
<code>bound</code> means boundary. I should understand it as the half-open <strong>equal-range
boundaries</strong> <code>[lower_bound, upper_bound)</code>. Within this range, all elements are
equal to the target.</p>
<p>We have <code>std::lower_bound</code> and <code>map::lower_bound</code>. What are the differences?
The former is implemented
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/lower_bound.h#L30">here</a>.
The latter is implemented
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__tree#L2156">here</a>.
<code>std::lower_bound</code> only requires <code>ForwardIterator</code>. The time complexity is
<code>O(logN)</code> for <code>RandomAccessIterator</code> but <code>O(NlogN)</code> for non random access
iterators because it uses <code>std::advance</code>. On the other hand, <code>map::lower_bound</code>
bisects to the left or right branch, so it is always <code>O(logN)</code>.</p>
<p>Another difference between <code>std::lower_bound</code> and <code>map::lower_bound</code> is that
the latter does not take an optional comparator because the comparator is
inherited from the map definition. The former can take an optional <code>comp</code>
argument. But be careful that this comparator is called as
<code>comp(*iter, target_value)</code>. This is useful when you have an sorted indices of
the original array. See example below. See the difference of the two
comparators.</p>
<pre><code class="language-cpp">vector&lt;int&gt; nums = {3, 1, 2};
vector&lt;int&gt; idxs = {0, 1, 2};
sort(idxs.begin(), idxs.end(), [&amp;nums](int a, int b) {return nums[a] &lt; nums[b]; }};
lower_bound(idxs.begin(), idxs.end(), [&amp;nums](int a, int b) {return nums[a] &lt; b; });
</code></pre>
<h2 id="binary-search"><a class="header" href="#binary-search">Binary Search</a></h2>
<p><code>std::binary_search</code> is just a wrapper of <code>std::lower_bound</code>. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/binary_search.h#L27">code</a>.
It returns <code>__first != __last &amp;&amp; !__comp(__value, *__first)</code>, i.e., a boolean
whether the target is found or not.</p>
<h2 id="meta-binary-search"><a class="header" href="#meta-binary-search">Meta binary search</a></h2>
<p>One interesting thing I learnt from reading libc++ code is
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/lower_bound.h#L61">meta binary search</a>.
The idea is very similar to radix sort. You try out index <code>1xxxxx</code> first. If
the value at index <code>100...0</code> is larger than the target, then you to <code>0xxxxx</code>.
Otherwise, you go to the second significant bit <code>11xxxx</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dp"><a class="header" href="#dp">DP</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="digit-dp"><a class="header" href="#digit-dp">Digit DP</a></h1>
<p>Problem statement:</p>
<pre><code>Count the number of integer say ‘x’ in the range [a, b]
such that x satisfies some conditions related to digits.
</code></pre>
<p><a href="https://codeforces.com/blog/entry/53960">cf blog</a> is a good introduction with
intuition. But I do not like the top-down recursive code it provides. I am more
interested in the bottom-up solution with clear base condition and recursion
formula.</p>
<p>Let’s define function <code>int calc(int num);</code> returns the satisfied integers in
range <code>[1, num]</code>, then the answer is <code>calc(b) - calc(a-1)</code>. Sometimes, it is
not trivial to calculate <code>a-1</code>. We can have a small trick in the dp process to
account for the inclusiveness. So the function interface becomes
<code>int cal(int num, bool inclusive);</code></p>
<p>The core part of digit dp is the concept of “tightness”. Let’s assume</p>
<pre><code>n: the total number of digits of intger num.
d0, d1, d_{n-1}: num's digits from left to right.
</code></pre>
<p>Then define</p>
<pre><code>dp[pos][k][tight]:
    Assume digits at position [0, pos-1] are all known,
    then the count for valid configurations up to `pos`.

---
pos: 0, 1, 2, ..., n

k: probelm related attribute/constraint. For example,
  - If the constraint is that the number has fixed number of odd digits,
    then k is the total odd digits in position [0, pos-1]
  - If the constraint is that adjencent digit are different, then k is the
    previous digit.

tight: boolean -&gt; digits in position [0, pos-1] are not tight or not.
</code></pre>
<h2 id="recursion-formula"><a class="header" href="#recursion-formula">Recursion formula</a></h2>
<!-- prettier-ignore-start -->
<p>\[
dp[pos][k][tight] = \sum_{i = 0}^{i \le up} dp[pos+1][k^{\prime}][tight^{\prime}]
\]</p>
<!-- prettier-ignore-end -->
<p>Here <code>up = tight ? d_pos : 9</code>. Basically, it means at position <code>pos</code>, you can
use digit <code>0</code>, <code>1</code>, …, <code>up</code>. And the new tight is determined by existing
tight and the digit chosen, i.e., <code>new_tight = tight == 0 or i &lt; up ? 0 : 1;</code>.</p>
<h2 id="base-condition"><a class="header" href="#base-condition">Base condition</a></h2>
<p>We initialize dp matrix as <code>dp[n+1][max_k][2]</code>. Why <code>n+1</code>? As said,
<code>dp[n][k][tight]</code> means the first <code>n</code> digits <code>[0, n-1]</code> are all fixed. So we
have base conditions.</p>
<pre><code>dp[n][valid k][0] = 1;

# The base tight case is equivalent to say num is counted or not.
dp[n][valid k][1] = inclusive ? 1 : 0;
</code></pre>
<h2 id="variations"><a class="header" href="#variations">Variations</a></h2>
<p>So far, we have assumed that the integer constraint has no relation with the
leading zero digits. For example, if the constraint is the total number of odd
digit should be fixed, then in this case <code>005</code> and <code>05</code> has the same odd digit
count. What if the constraint is the number of even digit. Then in the
recursion formula, when you choose <code>0</code> for the current digit, do you add it to
the event digit count? It depends whether this digit belongs to the leading
zero digits or not.</p>
<p>In this case, we introduce a new boolean dimension <code>started</code>:
<code>dp[pos][k][tight][started]</code>. The recursive formula for this dimension is</p>
<pre><code>new_started = started or (digit &gt; 0)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="string"><a class="header" href="#string">String</a></h1>
<h2 id="string-append"><a class="header" href="#string-append">String Append</a></h2>
<p>There are many ways to append one string to the end of another string.</p>
<ul>
<li><code>push_back</code>: append a single character.</li>
<li><code>append</code>: append a another string.</li>
<li><code>a = a + b</code>: create a new string. This is bad.</li>
<li><code>a += b</code>: same as append. No new string is created.</li>
</ul>
<p><code>a = a + b</code> is implemented
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/string#L3784">here</a>.
It creates a new string and copies the two strings to it. On the other hand,
<code>a += b</code> is just an alias for
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/string#L1332">append</a>.</p>
<p>Compiler cannot optimize <code>a = a + b</code> to <code>a += b</code> because it changes semantics.
Think about aliasing.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="kmp"><a href="#kmp" class="header">kmp</a></h1>
<h2 id="kmp-knuthmorrispratt"><a class="header" href="#kmp-knuthmorrispratt">KMP (Knuth–Morris–Pratt)</a></h2>
<p>Given a long string S (text) and a short string W (pattern), find all positions
in S such that the substring starting from that position equals W. Let
<code>n = len(S)</code> and <code>m = len(W)</code>, then the brute-force solution has time
complexity <code>O(n*m)</code>.</p>
<h3 id="intuition"><a class="header" href="#intuition">Intuition</a></h3>
<p>Key points:</p>
<ol>
<li>
<p>Construct <code>lps</code> : longest proper prefix which is also a suffix.</p>
<p><code>lps[i]</code> = the longest proper prefix of <code>W[0..i]</code> which is also a suffix of
<code>W[0..i]</code>. proper prefix means it is prefix but not equal to itself.</p>
</li>
<li>
<p>The mismatched position is the crucial part.</p>
</li>
</ol>
<p>Let’s simulation a case.</p>
<pre><code>i = current compare pos of S
j = current compare pos of W

01234567[8]90123456789012345 =&gt; S
    0123[4]56                =&gt; W
</code></pre>
<p>Above i = 8, j = 4, and we find <code>S[i] != W[j]</code>. What should we do?</p>
<p>For brute-force method, we simply shift W to right by one space and compare
from start again, namely,</p>
<pre><code>reset i = 5, j = 0.

01234[5]67890123456789012345 =&gt; S
     [0]123456               =&gt; W
</code></pre>
<p>Same for KMP, we need shift W to right, but the question is could we shift more
than one space? In this case, we already know that <code>S[4:7] = W[0:3]</code>. The
crucial part is that we should find a character in <code>W[0..x]</code> to compare <code>S[8]</code>.
We must have <code>x &lt; 4</code> since we will shift W to right. (Please think about this
part!) Suppose <code>x = 2</code></p>
<pre><code>01234567[8]90123456789012345 =&gt; S
      01[2]3456              =&gt; W
</code></pre>
<p>This configuration also means that <code>S[6:7]</code> = <code>W[0:1]</code>, but from about
<code>S[4:7] = W[0:3]</code>. So, we have <code>S[6:7] = W[0:1] = W[2:3]</code>, that is
<code>prefix = suffix</code>. In order to be conservative and not miss any possible
solution, we need x to be as large as possible, that is we need to find largest
proper <code>prefix = suffix</code>. That is <code>lps[i]</code>. Please draw the relation on a piece
of paper!</p>
<h3 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h3>
<p>Below Implementation is generated by Claude.ai. I explicitly ask him to make it
memorable. The key insight is that <strong>the same pattern works for both building
the LPS array and searching</strong>.</p>
<pre><code class="language-cpp">vector&lt;int&gt; kmp(const string&amp; text, const string&amp; pattern) {
    /******** Build LPS ********/
    int m = pattern.size();
    vector&lt;int&gt; lps(m);
    lsp[0] = 0; // why zero? Because it is proper prefix.

    // we start with i = 1, and in each iteration we guarantee to find lps[i].
    for (int i = 1, j=0; i &lt; m; i++) {
        // we the current character does not match, we move j to the last
        // longest proper prefix because the characters before that are guaranteed
        // to match and the move is conservative.
        while (j &gt; 0 &amp;&amp; pattern[i] != pattern[j]) j = lps[j - 1];

        // after the above loop, there are two possible outcome.
        // 1. pattern[i] == pattern[j] and j &gt;= 0. Note j could be zero in this case.
        // 2. pattern[i] != pattern[j] and j = 0. This case much have j = 0.
        if (pattern[i] == pattern[j]) j++;

        // for case #1, lsp[i] = (j - 0 + 1), but since we have j++ step above,
        // it becomes lsp[i] = j.
        // for case #2, j = 0, so lsp[i] = j = 0;
        lps[i] = j;
    }

    /******** Search ********/
    vector&lt;int&gt; matches;
    // For search, we start i, j both from zero.
    for (int i = 0, j = 0; i &lt; text.size(); i++) {
        while (j &gt; 0 &amp;&amp; text[i] != pattern[j]) j = lps[j - 1];
        if (text[i] == pattern[j]) j++;

        // when j==m, index of W goes out of range [0..m-1]
        // We can think of W[m] exits but definitely does not equal to S[i],
        // then we need assign j = lps[j-1].
        if (j == m) {
            matches.push_back(i - m + 1); // S[i-m+1, i] matches W.
            j = lps[j - 1];
        }
    }
    return matches;
}
</code></pre>
<p>The same pattern is as below.</p>
<pre><code>while j &gt; 0 and mismatch:
    j = lps[j - 1]
if match:
    j += 1
</code></pre>
<p>Memorization Tips:</p>
<ul>
<li>Two phases: Build LPS array, then search (same logic for both!).</li>
<li>Two pointers: <code>i</code> goes through text/pattern, <code>j</code> tracks match length.</li>
<li>On mismatch: Jump back using <code>j = lps[j - 1]</code> (keep doing this while
<code>j &gt; 0</code>).</li>
<li>On match: Just increment <code>j</code>.</li>
<li>Full match: When <code>j == len(pattern)</code>, you found it!</li>
</ul>
<p>What makes it “simple”:</p>
<ul>
<li>No complex cases to handle.</li>
<li>The LPS building and searching use almost identical code.</li>
<li>Just ~15 lines of actual logic.</li>
</ul>
<h4 id="trick"><a class="header" href="#trick">Trick</a></h4>
<p>As you see above, the two stages are almost the same. We can have a trick to
write fewer lines of code. Suppose there is a character such as <code>$</code> that does
not show up in either the text corps nor the pattern, then we can create a new
string <code>{pattern}${text}</code> and build LPS for it. What does the result mean?</p>
<ol>
<li>The prefix is <code>{pattern}$</code>, and <code>$</code> does not show up anywhere else. This
means <code>lps[i] &lt;= len(pattern)</code>.</li>
<li>If <code>lps[i] == len(pattern)</code>, then <code>s[i-len(pattern)+1..i]</code> matches pattern.
So we just iterate <code>lps</code> to find all indices. Note, because we prefixed
<code>len(pattern) + 1</code> to the original string, then the correct substring range
should be <code>s[i-len(patthern)-1-len(pattern)+1..i-len(pattern)-1]</code>, which is
<code>s[i-2*len(pattern)..i-len(pattern)-1]</code></li>
</ol>
<pre><code class="language-cpp">vector&lt;int&gt; kmp(const string&amp; s, const string&amp; p) {
  string s2 = p + "$" + s;
  int n = s2.size();
  vector&lt;int&gt; lps(n);
  for (int i = 1, j = 0; i &lt; n; i++) {
    while (j &gt; 0 and s2[i] != s2[j]) j = lps[j-1];
    if (s2[i] == s2[j]) j++;
    lps[i] = j;
  }
  vector&lt;int&gt; matches;
  for (int i = 0; i &lt; n; i++) {
    if (lps[i] == p.size()) matches.push_back(i - 2*p.size());
  }
  return matches;
}
</code></pre>
<h3 id="complexity"><a class="header" href="#complexity">Complexity</a></h3>
<ul>
<li>time complexity: <code>O(n+m)</code>.</li>
<li>space complexity <code>O(m)</code>.</li>
</ul>
<p>We all agree that <code>i</code> increases exactly by one in each outer loop iteration.
But <code>j</code> can move forward and backward inside the inner loop. So why complexity
is <code>O(n+m)</code> but not <code>O(n*m)</code>? We need amortized analysis.</p>
<ul>
<li><code>j</code> can increase by at most 1 per iteration.</li>
<li><code>j</code> starts at 0, max value is m.</li>
<li>Total increases: at most n.</li>
<li>Total decreases: at most n (can’t decrease more than it increased!).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="boyermoore"><a class="header" href="#boyermoore">Boyer–Moore</a></h1>
<p>This is also a string matching algorithm. It has sublinear time complexity for
regular cases, but worse <code>O(n*m)</code> complexity, so it is frequently used in
practice, but not good for competitive programming. By the way, C++ 17 and
above has std implementation for Boyer-Moore search algorithm.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="z-algorithm"><a class="header" href="#z-algorithm">Z algorithm</a></h1>
<p>The Z-function (or Z-algorithm) is a string processing algorithm that computes,
for each position in a string, the length of the longest substring starting at
that position which is also a prefix of the string. Given a string <code>s</code> of
length <code>n</code>, the Z-function of <code>s</code> is an array <code>Z</code> of length n where:</p>
<pre><code>Z[i] = max k such that s[0..k-1] == s[i..i+k-1]
</code></pre>
<p>This reminds me about the longest proper prefix suffix array in KMP.</p>
<p>I send below prompt to claude.ai.</p>
<blockquote>
<p>could you do an animation of z-algorithm with details about the definitions
of Z box and how it is updated?</p>
</blockquote>
<p>And it generated beautiful animation and detailed explanation. Below content is
mostly copied from claude. It summarizes better than me.</p>
<h2 id="what-is-the-z-box-l-r"><a class="header" href="#what-is-the-z-box-l-r">What is the Z-Box [L, R]?</a></h2>
<p>The Z-box is an interval <code>[L, R]</code> representing the <strong>rightmost</strong> segment of the
string where:</p>
<ul>
<li><code>s[L..R]</code> exactly matches <code>s[0..R-L]</code> (a prefix of the string).</li>
<li><code>R</code> is as large as possible (rightmost such segment we’ve found).</li>
<li>It helps us avoid redundant character comparisons.</li>
</ul>
<p>Two Main Cases:</p>
<ul>
<li>
<p>Case 1: <code>i &gt; R</code> (Outside the Z-box)</p>
<p>Position i is beyond our known matching segment. We must compare characters
from scratch to compute <code>Z[i]</code>, then update the Z-box to <code>[i, i+Z[i]-1]</code>.</p>
</li>
<li>
<p>Case 2: <code>i ≤ R</code> (Inside the Z-box)</p>
<p>Position i falls within <code>[L, R]</code>. We use the “mirror” position <code>k = i - L</code>.
Since <code>s[L..R]</code> matches <code>s[0..R-L]</code>, we know <code>s[i..R]</code> corresponds to
<code>s[k..R-L]</code>.</p>
<ul>
<li>
<p>Case 2a: <code>Z[k] &lt; r - i + 1</code></p>
<p>The match at k is fully contained. Simply copy: <code>Z[i] = Z[k]</code>. Z-box
unchanged.</p>
</li>
<li>
<p>Case 2b: <code>Z[k] ≥ r - i + 1</code></p>
<p>The match might extend beyond <code>R</code>. We know it matches up to <code>R</code>, but must
compare beyond to see how far it extends. Update Z-box to <code>[i, new_R]</code>.</p>
</li>
</ul>
</li>
</ul>
<p>The core intuition of Z algorithm is “rightmost”! There are a few invariants.
When we process index <code>i</code>, we must have <code>i &gt; L</code>, and <code>R &gt;= L - 1</code>. The
<code>R == L - 1</code> case corresponds to Z value being 0. Remember we use a close range
<code>[L, R]</code>.</p>
<h2 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h2>
<pre><code class="language-cpp">vector&lt;int&gt; compute_z_array(const string&amp; s) {
  int n = s.size();
  vector&lt;int&gt; Z(n); // Z[0] = 0 by tradition.

  int l = 0, r = 0; // Z-box [l, r]
  for (int i = 1; i &lt; n; i++) {
    if (i &gt; r) { // case 1.
      l = r = i;
      int tmp = 0;
      while (r &lt; n and s[r] == s[tmp++]) r++;
      Z[i] = --r - l + 1; // we need --r because it goes one index beyond.
    } else { // case 2.
      // s[i..r] == s[i-l, r-l] == s[k, r-l]
      int k = i - l;
      if (Z[k] &lt; r-i+1) Z[i] = Z[k];
      else {
        // in this case, we find a even more right range staring at i,
        // and s[i..r] == s[0, r-i], and there is potential to extend it.
        l = i;
        // node predefine tmp to r-i avoids bugs because below code updates r.
        int tmp = r-i;
        while (r &lt; n and s[r] == s[tmp++]) r++;
        Z[i] = --r - l + 1;
      }
    }
  }
  return Z;
}
</code></pre>
<h2 id="complexity-1"><a class="header" href="#complexity-1">Complexity</a></h2>
<ul>
<li>time complexity: <code>O(n)</code>. The Z-box boundary R only moves to the right (never
left). Each character comparison either increases R or we’re done with that
position. Since R can increase at most n times, total comparisons = <code>O(n)</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="hash"><a class="header" href="#hash">Hash</a></h1>
<p>Types supported by std::hash:</p>
<ul>
<li>
<p>all integral types: bool, int, float, enum, etc</p>
</li>
<li>
<p><code>std::string</code>: It uses murmur hash.</p>
</li>
<li>
<p>Raw pointer: hash the address. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__functional/hash.h#L332">code</a>.</p>
<p>This basically means below code <code>h(&amp;a)</code> and <code>h(&amp;b)</code> return different values.</p>
<pre><code>struct MyClass {};
MyClass a, b;
std::hash&lt;MyClass*&gt; h;
</code></pre>
</li>
<li>
<p><code>std::unique_ptr</code>: hash the address. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__memory/unique_ptr.h#L802">code</a>.
This is similar to raw pointer.</p>
</li>
<li>
<p><code>std::optional</code>: hash the value if present or just return zero. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/optional#L1278">code</a>.</p>
</li>
<li>
<p><code>std::variant</code>: combine hash of the value and index. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/variant#L1606">code</a>.
This makes sense because union types only has one correct view. It is
essentially the same as the backing type. But, not sure why we combine the
index information. To distinguish the two possibilities of
<code>variant&lt;int, int&gt;</code>? Wait. This is not even a valid variant.</p>
</li>
</ul>
<p>It does not support <code>vector</code> in general, but has a specialization for
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__vector/vector_bool.h#L1095">vector<bool></bool></a>.
What the hell!</p>
<h2 id="combine-hash"><a class="header" href="#combine-hash">Combine hash</a></h2>
<p>For non-supported types, we need to write the hash function by ourselves. It is
usually an art of combining hashes. See below example for <code>std::pair</code>.</p>
<pre><code class="language-cpp">class HashPair {

  template&lt;class A, class B&gt;
  size_t operator()(const pair&lt;A, B&gt;&amp; p) const {
    return std::hash&lt;A&gt;{}(p.first) ^ (std::hash&lt;B&gt;{}(p.second) &lt;&lt; 1);
  }
};
</code></pre>
<h3 id="why-h1--h2--1"><a class="header" href="#why-h1--h2--1">Why <code>h1 ^ (h2 &lt;&lt; 1)</code>?</a></h3>
<p>Why XOR? Among the three simplest bit operator AND, OR and XOR, XOR’s result is
evenly distributed. For example, for the 4 combinations of <code>0</code>, <code>1</code>, the XOR’s
result has two <code>0</code>s and two <code>1</code>s. AND produces one <code>1</code> and three <code>0</code>s. OR
produces three <code>1</code>s, and one <code>0</code>.</p>
<p>Why left shift? It makes order sensitive, so <code>hash(a, b) != hash(b, a)</code>.</p>
<h2 id="how-is-hash-requirement-enforced"><a class="header" href="#how-is-hash-requirement-enforced">How is hash requirement enforced?</a></h2>
<p>Some of them uses
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__functional/hash.h#L537">__enable_hash_helper</a>.
It requires all key types to be hashable.</p>
<p>Some of them put it in the destructor. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/unordered_set#L1337">example</a>.
Why?</p>
<p>Below is AI’s response.</p>
<ol>
<li>
<p>Incomplete Types at Instantiation: When you instantiate a class template
like std::unordered_set<mytype>, MyType can be an incomplete type at that
point. An incomplete type is a type that has been declared but not yet
fully defined (e.g., class MyType;). You can have pointers and references
to incomplete types, but you can’t know their size or access their members.</mytype></p>
</li>
<li>
<p><code>static_assert</code> Requires Complete Types: A static_assert that inspects the
properties of a type (like checking if it’s copy-constructible or if it has
a specific function call operator) requires the type to be complete. If the
static_assert were placed at the top of the unordered_set class definition,
it would be checked as soon as you write std::unordered_set<mytype>. If
MyType is incomplete at that point, the compilation would fail, even if
MyType is defined later in the same file.</mytype></p>
</li>
<li>
<p>Delayed Instantiation of the Destructor: The body of a class template’s
member function (including the destructor) is not instantiated until it is
actually used or explicitly instantiated. By placing the static_assert in
the destructor, the check is delayed until the point where an unordered_set
object is actually destroyed. By that time, any template arguments that
were incomplete types must have been completed.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="math"><a class="header" href="#math">Math</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="utility-functions"><a class="header" href="#utility-functions">Utility Functions</a></h1>
<h2 id="gcd-greatest-common-divisor-and-lcm-least-common-multiplier"><a class="header" href="#gcd-greatest-common-divisor-and-lcm-least-common-multiplier">GCD (Greatest Common Divisor) and LCM (Least Common Multiplier)</a></h2>
<p>Both <code>std::gcd</code> and <code>std::lcm</code> were introduced in c++17, so most time, you do
not need to implement them by themself. However, for reference, see below
one-liner implementation for <code>gcd</code>.</p>
<pre><code class="language-cpp">int gcd(int a, int b) { return a == 0 ? b : gcd(b%a, a); };
</code></pre>
<p>Also, in some case, we need overflow protection, we can have below <code>lcm</code>
implementation.</p>
<pre><code class="language-cpp">using ll = long long;
ll lcm(ll a, ll b, ll limit) {
    int gcd = std::gcd(a, b);
    if (a / gcd &gt; limit / b) return limit + 1; // return a number larger than limit indicating overflow.
    return a / gcd * b;
}
</code></pre>
<h2 id="binomial-coefficients-without-overflow"><a class="header" href="#binomial-coefficients-without-overflow">Binomial Coefficients Without Overflow</a></h2>
<p>I asked this question to claude.ai, and it gives me quite a few good
approaches. Here, I just list the exact Multiplicative Formula approach.</p>
<pre><code class="language-cpp">long long binomial(int n, int k) {
    if (k &gt; n - k) k = n - k;  // Symmetry

    long long result = 1;
    for (int i = 0; i &lt; k; i++) {
        result = result * (n - i) / (i + 1);
    }
    return result;
}
</code></pre>
<p>You may wonder why <code>result * (n-i)</code> is divisible by <code>i+1</code>. This is because
<code>C(n, k+1) = C(n, k) * (n-k) / (k+1)</code> which is guaranteed to be divisible.</p>
<h2 id="all-dividends"><a class="header" href="#all-dividends">All dividends</a></h2>
<p>Not all problems require linear or <code>log(N)</code> complexity, some math problems can
have a complexity factor of <code>sqrt(N)</code>. All dividends is one of them.</p>
<pre><code class="language-cpp">unordred_set&lt;int&gt; dividents(int x) {
  unordred_set&lt;int&gt; ans;
  for (int i = 1; i * i &lt;= x; i++) {
    if (x % i != 0) continue;
    ans.insert(i);
    ans.insert(x/i);
  }
  return ans;
}
</code></pre>
<h2 id="prime-factorization"><a class="header" href="#prime-factorization">Prime Factorization</a></h2>
<pre><code class="language-cpp">vector&lt;int&gt; primeFactorization(int n) {
    vector&lt;int&gt; factors;

    while (n % 2 == 0) { factors.push_back(2); n = n / 2; }
    for (int i = 3; i * i &lt;= n; i += 2) {
        while (n % i == 0) { factors.push_back(i); n = n / i; }
    }

    if (n &gt; 1) factors.push_back(n);
    return factors;
}
</code></pre>
<h2 id="harmonic-series"><a class="header" href="#harmonic-series">Harmonic Series</a></h2>
<p>This is related to all dividends, some math problem may have complexity
<code>N + N/2 + N/3 + .. + N/N</code>. This is called [Harmonic
Series](https://en.wikipedia.org/wiki/Harmonic_series_(mathematics) which has
complexity <code>log(N)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fermats-little-theorem"><a class="header" href="#fermats-little-theorem">Fermat’s Little Theorem</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Fermat%27s_little_theorem">Fermat’s little theorem</a>
states that</p>
<!-- prettier-ignore-start -->
<p>\[
a^{p-1} \equiv 1 \pmod{p} \quad \text{if $p$ is prime and $a$ is coprime to $p$.}
\]</p>
<!-- prettier-ignore-end -->
<p><code>Coprime</code> means the only positive integer that is a divisor of both of <code>a</code> and
<code>p</code> is 1. Since <code>p</code> is a prime, this means as long as <code>a</code> is smaller than p,
then they are coprimes. In most competitive programming, <code>p</code> is super large
number like <code>1e9 + 7</code>, so the coprime condition is valid.</p>
<h2 id="applications-1"><a class="header" href="#applications-1">Applications</a></h2>
<p>One common application in competitive programming is evaluating modulo of
fraction numbers.</p>
<!-- prettier-ignore-start -->
<p>\[
\frac{x}{a} \equiv \frac{x\cdot a^{p-2}}{a \cdot a^{p-2}} \equiv x \cdot a^{p-2} \pmod{p}
\]</p>
<!-- prettier-ignore-end -->
<h3 id="example-multinomial-coefficient"><a class="header" href="#example-multinomial-coefficient">Example: Multinomial Coefficient</a></h3>
<pre><code class="language-cpp">long fact[100'001];
int mod = 1e9 + 7;

long modpow(long x, int n) {
  if (n == 0) return 1;
  long h = modpow(x, n/2);
  return h * h % mod * (n%2==1 ? x : 1) % mod;
}

// Calculate multinomial coefficient n!/(n1! * n2! * ...)
// where n = n1 + n2 + ...
long multinomial(const vector&lt;int&gt;&amp; ns) {
    int n = accumulate(ns.begin(), ns.end(), 0);
    fact[0] = 1;
    for (int i = 1; i &lt;= n; i++) {
        fact[i] = i * fact[i-1] % mod;
    }
    long ans = fact[n];
    for (int ni : ns) {
        ans = ans * modpow(fact[ni], mod-2) % mod;
    }
    return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sieve-of-eratosthenes"><a class="header" href="#sieve-of-eratosthenes">Sieve of Eratosthenes</a></h1>
<ul>
<li>Time complexity: <code>O(nlog(log(n))</code></li>
</ul>
<pre><code class="language-cpp">int n = 10000;
std::vector&lt;bool&gt; is_prime(n + 1, true);
is_prime[0] = is_prime[1] = false;

for (int i = 2; i * i &lt;= n; i++) { // check up to sqrt(n).
    if (not is_prime[i]) continue;
    for (int j = i * i; j &lt;= n; j += i) { // start from i^2.
        is_prime[j] = false;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bit-operation"><a class="header" href="#bit-operation">Bit Operation</a></h1>
<p>A few commonly used std functions. There are corresponding CPU instructions for
them, so it is very fast.</p>
<ul>
<li><code>std::popcount(T x)</code>: Returns the number of 1 bits in the value of x.</li>
<li><code>std::bit_width(T x)</code>: the number of bits needed to store the value x.
<ul>
<li>MSB (most significant bit): <code>std::bit_width(x) - 1</code>.</li>
</ul>
</li>
<li><code>std::countl_zero(T x)</code>.</li>
<li><code>std::countl_one(T x)</code>.</li>
</ul>
<p>The LLVM implementation is
<a href="https://github.com/llvm/llvm-project/tree/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__bit">here</a>.
These functions are overkill for most cases. We can simply use a for loop to
achieve we want</p>
<pre><code class="language-cpp">for (int i = 31; i &gt;= 0; i--) if ((x &amp; (1&lt;&lt;i)) != 0)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="inclusion-exclusion-principle"><a class="header" href="#inclusion-exclusion-principle">Inclusion-Exclusion Principle</a></h1>
<p>The problem statement:</p>
<pre><code>Goal: Count elements in A₁ ∪ A₂ ∪ ... ∪ Aₙ

Formula: |A₁ ∪ ... ∪ Aₙ| =
  Σ(single sets) - Σ(pairs) + Σ(triples) - ... + (-1)^(n+1) Σ(all n)
</code></pre>
<p>This formula looks daunting in the first appearance. How could you enumerate
all these combinations? It is definitely extremely hard in the general case.
However, in competitive programming context, <code>n</code> is usually less than <code>32</code>, so
we can use bit mask to enumerate the set. The pseudocode is what follows.</p>
<pre><code class="language-cpp">// Input: vector&lt;int&gt; A =&gt; represent the array we need apply some count on it.

int n = A.size();
int total = 0;

for (int mask = 1; mask &lt; (1&lt;&lt;n); mask++) {
    int bits = 0; // number of element in the set.
    for (int i = 0; i &lt; n; i++) {
        if ((1&lt;&lt;i) &amp; mask) {
            // A[i] is chosen, do the counting here.
            ...

            // Also, do not forget count included elements.
            bits++;
        }
    }
    cout == ... // business logic related

    // Inclusion-exclusion: odd size adds, even size subtracts
    if (bits % 2 == 1) {
        total += count;
    } else {
        total -= count;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="build-from-source"><a class="header" href="#build-from-source">Build from source</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="curl"><a class="header" href="#curl">curl</a></h1>
<p>Curl’s <a href="https://curl.se/docs/install.html">official installation page</a> is not
accurate. To build <code>curl</code> locally, see below instructions.</p>
<pre><code class="language-bash">./buildconf
./configure --with-openssl
bear -- make -j5
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
