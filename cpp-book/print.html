<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>All I know about C++</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/code-details.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">All I know about C++</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book contains all I know about C++: standard drafts, compiler
implementation, data structures, algorithms, competitive programming skills and
etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-standards"><a class="header" href="#c-standards">C++ Standards</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="9-declarations"><a class="header" href="#9-declarations">9 Declarations</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initializers"><a class="header" href="#initializers">Initializers</a></h1>
<p>Initialization in C++ is complicated. See
<a href="https://eel.is/c++draft/dcl.init">C++ standard</a>. If you believe you are an
expert in this area, then please answer the below questions.</p>
<ol>
<li>For <code>int arr[5];</code>, are all 5 elements initialized to zero?</li>
<li>How about <code>int arr[5] = {};</code>?</li>
<li>How about <code>int arr[5] = {1};</code>?</li>
<li>For <code>vector&lt;int&gt; v(5);</code>, are all 5 elements initialized to zero?</li>
<li>How about <code>vector&lt;pair&lt;int, int&gt;&gt; v(5);</code>?</li>
<li>How about <code>array&lt;int, 3&gt; a;</code> and <code>vector&lt;array&lt;int, 3&gt;&gt; v(5);</code>?</li>
</ol>
<p>We need to cover at least concepts: <code>default initialization</code>,
<code>zero initialization</code> and <code>value initialization</code>.</p>
<h2 id="value-initialization"><a class="header" href="#value-initialization">Value Initialization</a></h2>
<p><a href="https://eel.is/c++draft/dcl.init#general-9">dcl.init#general-9</a> covers value
initialization. It covers 3 cases: class type, array type and others.</p>
<h3 id="others"><a class="header" href="#others">Others</a></h3>
<p>Let's see the others' case. The standard draft says</p>
<blockquote>
<p>Otherwise, the object is zero-initialized.</p>
</blockquote>
<p>Also, the zero initialization sections says</p>
<blockquote>
<p>if T is any other scalar type, the object is initialized to the value
obtained by converting the integer literal 0 (zero) to T;</p>
</blockquote>
<p>So for <code>int</code>, <code>float</code> etc. value initialization means setting to zero. For
example, <code>float x {};</code> explicitly sets <code>x</code> to <code>0</code>. While <code>float x;</code> is default
initialization. How is a primitive default initialized? Section <code>general-7.4</code>
says no initialization is performed, which mean it is random, i.e., any garbage
value at that stack location.</p>
<p>So remember: <strong>scalar type value-initialization is zero-initialization</strong>.</p>
<h3 id="class-type"><a class="header" href="#class-type">Class type</a></h3>
<p>If <code>T</code> is a class type, and if it has a user-provided constructor, then it this
constructor is used. If no such constructor, then it is zero initialized.
<strong>After that, the object is then default initialized.</strong></p>
<p>For example, a simple class as below</p>
<pre><code class="language-cpp">struct A {
  int x, y;
  A(int y): y(y) {}
};

A a(5);
</code></pre>
<p>It has a user-provided constructor. It is first called, so <code>y</code> is initialized
to <code>5</code>. How about <code>x</code>? It is default initialized and thus a random value. If we
change <code>int x, y;</code> to <code>int x = 0; int y;</code>, then it is default to zero.</p>
<p>Let's see another case <code>vecotr&lt;int&gt; v(5);</code>. The vector self is
value-initialized. How about its elements? cppconference.com says "Constructs a
vector with count default-inserted objects of T. No copies are made." What does
<code>default-inserted</code> means? The standard section
<a href="https://eel.is/c++draft/container.requirements#container.alloc.reqmts-2.2">container.requirements#container.alloc.reqmts-2.2</a>
says</p>
<pre><code>An element of X is default-inserted if it is initialized by evaluation of the
expression `allocator_traits&lt;A&gt;::construct(m, p)`.
</code></pre>
<p>I checked the libc++ implementation. The final piece is this
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__memory/construct_at.h#L38">construct_at</a>
function. It basically says</p>
<pre><code>return ::new (static_cast&lt;void*&gt;(__location)) _Tp(std::forward&lt;_Args&gt;(__args)...);
</code></pre>
<p>For this vector example, <code>__args</code> is empty, thus it is simplified to
<code>::new int();</code>. You can test it out<sup class="footnote-reference" id="fr-note1-1"><a href="#footnote-note1">1</a></sup>, this is value initialization!
Therefore, <code>vector&lt;int&gt; v(5);</code> initializes all elements to zero.</p>
<h4 id="why-is-new-t-value-initialized"><a class="header" href="#why-is-new-t-value-initialized">Why is <code>new T(...)</code> value initialized?</a></h4>
<p>Let's present the result first:</p>
<ul>
<li><code>new T()</code> → value initialization (zeros for primitive types).</li>
<li><code>new T</code> → default initialization (indeterminate for primitive types).</li>
</ul>
<p><a href="https://eel.is/c++draft/dcl.init#general-16.4">dcl.init#general-16.4</a> says "If
the initializer is (), the object is value-initialized." But <code>()</code> cannot be
used as initializer in most cases. The few exceptions include the <code>new</code>
operator. Then <a href="https://eel.is/c++draft/expr.new#24">expr.new#24</a> says "If the
new-initializer is omitted, the object is default-initialized. Otherwise, the
new-initializer is interpreted according to the initialization rules of
[dcl.init] for direct-initialization." So it makes a huge difference if there
is <code>()</code> or not in the <code>new</code> expression.</p>
<p>Not just for <code>int</code>, it applies to <code>vector&lt;pair&lt;int, int&gt;&gt;</code> and
<code>vector&lt;tuple&lt;int, float&gt;&gt;</code> as well. The default constructor of <code>pair</code> and
<code>tuple</code> both value-initializes all elements. It is explicitly written in
cppconference.com. Similar goes with <code>vector&lt;array&lt;int, N&gt;&gt;</code>. The values are
all zero.</p>
<h3 id="array-type"><a class="header" href="#array-type">Array type.</a></h3>
<p>Lastly, if <code>T</code> is an array type, then all its elements are value initialized.
Let's analyze three cases:</p>
<ul>
<li><code>int arr[5];</code>: default initialization. These 5 elements are random.</li>
<li><code>int arr[5] = {};</code>: value initialization. Each element is value initialized.
As said above, each one is zero-initialized. So this is equivalent to
<code>int arr[5] = {0, 0, 0, 0, 0};</code>;</li>
<li><code>int arr[5] = {1, 2};</code>: value initialization.
<a href="https://eel.is/c++draft/dcl.init#general-16.5">dcl.init#general-16.5</a> has a
special paragraph for this case. Basically, element <code>e_i</code> is copy initialized
for <code>1 &lt;= i &lt;= k</code> and remaining elements are value-initialized. so this is
equivalent to <code>int arr[5] = {1, 2, 0, 0, 0};</code>.</li>
</ul>
<h2 id="answers-to-the-questions-at-the-beginning"><a class="header" href="#answers-to-the-questions-at-the-beginning">Answers to the questions at the beginning.</a></h2>
<ol>
<li>No. The elements are random because <code>arr</code> is default initialized.</li>
<li>Yes. All zeros because <code>arr</code> is value initialized.</li>
<li>The first element is <code>1</code>. The rest is <code>0</code>.</li>
<li>Yes. All zeros;</li>
<li>Yes. All pairs have zero first and zero second parts.</li>
<li><code>array&lt;int, 3&gt; a;</code> has random values. <code>vector&lt;array&lt;int, 3&gt;&gt; v(5);</code> are all
initialized to zero.</li>
</ol>
<hr>
<ol class="footnote-definition"><li id="footnote-note1">
<p>Please do exactly as <code>int *p = new int();</code> because <code>int a();</code> won't give
what you want. Checkout "most vexing parse". <a href="#fr-note1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="comparator"><a class="header" href="#comparator">Comparator</a></h1>
<p><code>std::sort</code> can pass a <code>comp</code> parameter at the end. If not specified, then it
is defaults to
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/sort.h#L967">std::less</a>.</p>
<p>Sometimes, we want to sort nested containers, then how comparison works for
them.</p>
<p>For vector, it is defined as
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__vector/comparison.h#L49">std::lexicographical_compare</a>.
Basically, it compares element by element until a different one is found or one
vector goes out of range. In the latter case, the short vector is smaller.
<code>std:string</code>, <code>std::deque</code>, <code>std::array</code> <code>std::pair</code> and <code>std::tuple</code> are
similar to vector. They compare from the first element. If equal, then the
second, and the rest.</p>
<p><code>std::set</code> and <code>set::map</code> define <code>operator&lt;</code> as well. It is lexicographical
order as well. However, <code>std::unordered_set</code> and <code>std::unordered_map</code> only
define <code>operator==</code> and <code>operator!=</code>.</p>
<p>Comparator is also used extensively in sorted containers. <code>std::set</code> and
<code>std::map</code> has comparator template argument. There is a caveat that</p>
<blockquote>
<p>Everywhere the standard library uses the Compare requirements, uniqueness is
determined by using the equivalence relation. In imprecise terms, two objects
a and b are considered equivalent if neither compares less than the other:
!comp(a, b) &amp;&amp; !comp(b, a).</p>
</blockquote>
<p>The concrete code is
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__tree#L1705">here</a>.
Both <code>set</code> and <code>map</code> are implemented using red-black tree. When inserting a new
element, The case <code>not a &lt; b and not b &lt; a</code> means two keys are equal. If you
forget tie breaker, then you may end up with a undetermined behavior. For
example, in Dijkstra shortest path algorithm, we should define the comparator
as</p>
<pre><code class="language-cpp">auto comp = [&amp;distances](const string &amp;a, const string &amp;b) {
    if (distances[a] != distances[b])
        return distances[a] &lt; distances[b];
    return a &lt; b;
};
</code></pre>
<h1 id="radix-sort"><a class="header" href="#radix-sort">Radix Sort</a></h1>
<p>libc++ has a good demonstration of the usage of radix sort. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/stable_sort.h#L256">code</a>.</p>
<p>First, it is only used if the container value type is integral. It works for
int32, int64, etc but not floats, strings. Also, it supports negative integrals
as well. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/radix_sort.h#L298">code</a>.
Using int8 as an example, the trick <code>numeric_limits&lt;_Ip&gt;::min() ^ value</code> can be
explained by below table.</p>
<pre><code>┌───────────────────┬───────────────────────┬──────────────────────────┬───────────────────┐
│ Original (Signed) │ Binary Representation │ XOR with -128 (10000000) │ Result (Unsigned) │
├───────────────────┼───────────────────────┼──────────────────────────┼───────────────────┤
│ -128              │ 10000000              │ 10000000 ^ 10000000      │ 00000000 (0)      │
│ -127              │ 10000001              │ 10000001 ^ 10000000      │ 00000001 (1)      │
│ -1                │ 11111111              │ 11111111 ^ 10000000      │ 01111111 (127)    │
│ 0                 │ 00000000              │ 00000000 ^ 10000000      │ 10000000 (128)    │
│ 1                 │ 00000001              │ 00000001 ^ 10000000      │ 10000001 (129)    │
│ 127               │ 01111111              │ 01111111 ^ 10000000      │ 11111111 (255)    │
└───────────────────┴───────────────────────┴──────────────────────────┴───────────────────┘
</code></pre>
<p>It maps <code>[-128, 127]</code> to <code>[0, 255]</code> without changing the relative order.</p>
<p>Second, in the competitive coding context, most people will do radix sorting by
comparing the decimal digits, but libc++
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/radix_sort.h#L306">compares bytes</a>.</p>
<p>Third, radix sorting uses counting sort. The basic idea is counting the digit
occurrence and do a prefix sum, so we know the position in the sorted array
given a digit. The caveat is to maintain the stable order. If two numbers have
the same digit, their relative order should not change. The pseudocode is</p>
<pre><code class="language-cpp">void counting_sort(vector&lt;int&gt;&amp; arr, int exp) {
    int n = arr.size();
    vector&lt;int&gt; output(n), count(10, 0);

    // frequency prefix sum.
    for (int i = 0; i &lt; n; i++) count[(arr[i] / exp) % 10]++;
    for (int i = 1; i &lt; 10; i++) count[i] += count[i - 1];

    // start from the right end and decrease the frequency so we can maintain
    // stable order.
    for (int i = n - 1; i &gt;= 0; i--) {
        int digit = (arr[i] / exp) % 10;
        output[count[digit] - 1] = arr[i];
        count[digit]--;
    }
    arr = output;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="priority-queue"><a class="header" href="#priority-queue">Priority Queue</a></h1>
<p>I do not like <code>std::priority_queue</code> because it does not provide the <code>begin</code> nor
<code>end</code> iterator. Later on, I learned a set of functions to deal with max heap
directly: <code>make_heap</code>, <code>push_heap</code> and <code>pop_heap</code>. I am very happy with it
because it allows me implementing priority queue on top of vector, and I can
iterate vector! Then I suspect the push/pop operation of <code>std::priority_queue</code>
is just a wrapper of <code>push_heap</code>/<code>pop_heap</code>. It is! See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/queue#L899">code</a>.</p>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<p>A few examples.</p>
<pre><code class="language-cpp">priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; pq;
</code></pre>
<pre><code class="language-cpp">auto comp = std::greater&lt;int&gt;{};
priority_queue&lt;int, std::vector&lt;int&gt;, decltype(comp)&gt; pq(comp);
</code></pre>
<pre><code class="language-cpp">vector v = {1, 2, 3, 5};
priority_queue&lt;int&gt; pq(v.begin(), v.end());
</code></pre>
<p>Just want to point out the last constructor has time complexity <code>O(N)</code>, not
<code>O(NlogN)</code>. Underneath, it just calls
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/queue#L786">std::make_heap</a>.</p>
<h2 id="heap"><a class="header" href="#heap">Heap</a></h2>
<p>What is a max heap?</p>
<ol>
<li>
<p>A heap must be a complete binary tree, meaning all levels are fully filled
except possibly the last level, which fills from left to right. If we store
it in an array <code>arr</code> with <code>arr[0]</code> being the root, then left and right of
<code>arr[i]</code> are <code>arr[2*i+1]</code> and <code>arr[2*i+2]</code>.</p>
</li>
<li>
<p>For max heap, every parent node is greater or equal to its children. Min
heap is reverse.</p>
</li>
</ol>
<p>The bottom-up heapify process takes <code>O(N)</code> steps.</p>
<pre><code class="language-cpp">void heapify_down(vector&lt;int&gt;&amp; a, int n, int i) {
    int mx = i, l = 2*i + 1, r = 2*i + 2;
    if (l &lt; n &amp;&amp; a[l] &gt; a[mx]) mx = l;
    if (r &lt; n &amp;&amp; a[r] &gt; a[mx]) mx = r;
    if (mx != i) {
        swap(a[i], a[mx]);
        heapify_down(a, n, mx);
    }
}

// Build max heap - O(n)
void make_heap(vector&lt;int&gt;&amp; a) {
    for (int i = a.size()/2 - 1; i &gt;= 0; i--)
        heapify_down(a, a.size(), i);
}

// Insert element at end and heapify up - O(log n)
void push_heap(vector&lt;int&gt;&amp; a) {
    int i = a.size() - 1;
    while (i &gt; 0 &amp;&amp; a[(i-1)/2] &lt; a[i]) { // parent at index (i-1)/2
        swap(a[i], a[(i-1)/2]);
        i = (i-1)/2;
    }
}

// Remove max (root), move last to root, heapify down - O(log n)
void pop_heap(vector&lt;int&gt;&amp; a) {
    swap(a[0], a[a.size()-1]);
    heapify_down(a, a.size()-1, 0);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-graph"><a class="header" href="#tree-graph">Tree, Graph</a></h1>
<p>A tree is an undirected, connected, and acyclic graph. It has <code>n</code> nodes, <code>n-1</code>
edges and is fully connected. This setup often shows up in competitive
programming.</p>
<p>Realizing it is a tree is helpful for DFS because often times the graph
definition contains not only the child nodes but also the parent node. A simple
trick to skip going back is</p>
<pre><code class="language-cpp">for (next : graph[node]):
    if (next == parent_node) continue
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segment-tree"><a class="header" href="#segment-tree">Segment Tree</a></h1>
<p>A segment tree is a binary tree data structure used to efficiently answer range
queries and perform range updates on an array — such as:</p>
<ul>
<li>Range sum</li>
<li>Range minimum/maximum</li>
<li>Range gcd, etc.</li>
</ul>
<p>It’s designed to balance query speed and update speed, both in O(log N) time.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>A few conventions to reduce chances of mistakes.</p>
<ol>
<li>left branch is <code>[l, m]</code>, right branch is <code>[m+1, r]</code>. This avoids the index
of out of range error for the middle point <code>(l+r)/2</code>.</li>
</ol>
<p>Below is the naive implementation using explicit tree node.</p>
<details class="code-details">
<summary> struct Node; </summary>
<pre><code class="language-cpp">struct Node {
    int l, r;
    shared_ptr&lt;Node&gt; left, right;
    int s; // each node stores the sum of the range [l,r].
    Node(int l, int r): l(l), r(r), s(0) {}
};
using NodeP = shared_ptr&lt;Node&gt;;

NodeP root;

void create_children(NodeP node) {
     if (node-&gt;l != node-&gt;r) {
        int m = (node-&gt;l + node-&gt;r) / 2;
        if (not node-&gt;left) node-&gt;left = make_shared&lt;Node&gt;(node-&gt;l, m);
        if (not node-&gt;right) node-&gt;right = make_shared&lt;Node&gt;(m+1, node-&gt;r);
    }
}

int query(NodeP node, int l, int r) {
    int m = (node-&gt;l + node-&gt;r) / 2;
    create_children(node);
    if (node-&gt;l == l and node-&gt;r == r) {
        return node-&gt;s;
    }

    if (r &lt;= m) return search(node-&gt;left, l, r);
    else if (l &gt; m) return search(node-&gt;right, l, r);
    else return search(node-&gt;left, l, m) + search(node-&gt;right, m+1, r);
}

// Add val to the existing value at node i.
void update(NodeP node, int i, int val) {
  create_children();
  node-&gt;s += val;
  if (node-&gt;l == i and node-&gt;r == i) return;
  int m = (node-&gt;l + node-&gt;r) / 2;
  if (i &lt;= m) update(node-&gt;left, i, val);
  else update(node-&gt;right, i, val);
}
</code></pre>
</details>
<p>Most segment tree code you see online uses an array to represent the tree. See
<a href="https://www.hackerearth.com/practice/notes/segment-tree-and-lazy-propagation/">example</a>.
An array <code>int tree[2n+1]</code> represent a tree with <code>n</code> nodes. <code>tree[k]</code> has
children <code>tree[2k]</code> and <code>tree[2k+1]</code>. Root node is <code>tree[1]</code>. However, I do not
like this implementation because it makes the interface more verbose. In my
implementation, <code>struct Node</code> contains the boundary information <code>l</code> and <code>r</code>.
With the array approach, the interface becomes
<code>int query(int node, int start, int end, int l, int r)</code>. The first 3 parameters
are the node index, left and right boundary.</p>
<h2 id="lazy-propagation"><a class="header" href="#lazy-propagation">Lazy Propagation</a></h2>
<p>The basic search and update operation has <code>O(logN)</code> complexity. It is not
efficient for range update. To make it <code>O(logN)</code> as well, we need lazy
propagation. A new helper <code>push</code> introduced. It realized the laziness at the
current node, and push the laziness down to its children. There are four places
we need <code>push</code>. First, at the beginning of a query, which is obvious. Then 3
places in <code>update</code>:</p>
<ol>
<li>At the beginning of <code>update</code>.</li>
<li>At the base condition, i.e., query range equals node's boundary. This is
where the performance improvement comes from. It avoids going deep to leaf
nodes, and simply put a marker in the current node saying: all nodes under
this subtree have an un-realized update amount <code>inc_amount</code>.</li>
<li>Before we finally update current node's value. This is pre-order traversal.
We need to make sure the left and right children do not have any lazy value
before we add them up. Otherwise, it would be wrong. This is most popular
mistake I made!</li>
</ol>
<details class="code-details">
<summary> Lazy Propagation </summary>
<pre><code class="language-cpp">struct Node {
    int l, r;
    shared_ptr&lt;Node&gt; left, right;
    int lazy = 0; // lazy update amount
    int s;
    Node(int l, int r): l(l), r(r), s(0) {}
};
using NodeP = shared_ptr&lt;Node&gt;;

NodeP root;

void create_children(NodeP node) {
     if (node-&gt;l != node-&gt;r) {
        int m = (node-&gt;l + node-&gt;r) / 2;
        if (not node-&gt;left) node-&gt;left = make_shared&lt;Node&gt;(node-&gt;l, m);
        if (not node-&gt;right) node-&gt;right = make_shared&lt;Node&gt;(m+1, node-&gt;r);
    }
}

// realize laziness at current node and push it down the tree.
void push(NodeP node) {
    if (node-&gt;lazy) {
        node-&gt;s += node-&gt;lazy * (node-&gt;r - node-&gt;l + 1);
        // only push down when it is not a leaf node.
        if (node-&gt;l != node-&gt;r) {
            node-&gt;left-&gt;lazy += node-&gt;lazy;
            node-&gt;right-&gt;lazy += node-&gt;lazy;
        }
        // remember to reset laziness.
        node-&gt;lazy = 0;
    }
}

int query(NodeP node, int l, int r) {
    int m = (node-&gt;l + node-&gt;r) / 2;
    create_children(node);
    // realize laziness before query.
    push(node);
    if (node-&gt;l == l and node-&gt;r == r) {
        return node-&gt;s;
    }

    if (r &lt;= m) return search(node-&gt;left, l, r);
    else if (l &gt; m) return search(node-&gt;right, l, r);
    else return search(node-&gt;left, l, m) + search(node-&gt;right, m+1, r);
}

void update(NodeP node, int l, int r, int inc_amount) {
    int m = (node-&gt;l + node-&gt;r) / 2;
    create_children(node);
    push(node);

    if (node-&gt;l == l and node-&gt;r == r) {
        node-&gt;lazy += inc_amount;
        push(node);
        return;
    }
    if (r &lt;= m) {
        insert(node-&gt;left, l, r);
    } else if (l &gt; m) {
        insert(node-&gt;right, l, r);
    } else {
        insert(node-&gt;left, l, m);
        insert(node-&gt;right, m+1, r);
    }
    // make sure left and right do not have un-realized updates.
    push(node-&gt;left); push(node-&gt;right);
    node-&gt;s = node-&gt;left-&gt;s + node-&gt;right-&gt;s;
}
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fenwick-tree"><a class="header" href="#fenwick-tree">Fenwick Tree</a></h1>
<p>A Fenwick tree (also called a Binary Indexed Tree or BIT) is a data structure
that efficiently supports two operations on an array:</p>
<ul>
<li>Update: Modify a single element</li>
<li>Prefix sum query: Calculate the sum of elements from index 0 to any given
index</li>
</ul>
<p>Both operations run in <code>O(log n)</code> time. So the difference between BIT and
segment tree is that the latter can define different aggregation; while the
former is only for prefix sum query. See the "Policy-Based Data Structures"
post about which to choose.</p>
<h2 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h2>
<p>The key insight is that any number can be represented as a sum of powers of 2.
The Fenwick tree stores partial sums in a clever way where:</p>
<ul>
<li>Each index is responsible for a range of elements.</li>
<li>The range size is determined by the lowest set bit in the index.</li>
</ul>
<p>Index <code>2^k</code> stores sum of index <code>2^{k-1} + 1</code>, <code>2^{k-1} + 2</code>, ... <code>2^k</code>. Note
index starts from <code>1</code> not <code>0</code>. For example, in a Fenwick tree:</p>
<ul>
<li>Index 1 (binary: 001) stores sum of 1 elements: <code>001</code>.</li>
<li>Index 4 (binary: 100) stores sum of 4 elements: <code>001</code>, <code>010</code>, <code>011</code>, <code>100</code></li>
<li>Index 6 (binary: 110) stores sum of 2 elements: <code>110</code>, <code>101</code>.</li>
</ul>
<p>From this we can see given an index <code>i</code>, it must be responsible for the value
at index itself. Then we change the lowest set bit to zero, and sums up all
indices with combinations of the lower bits.</p>
<pre><code class="language-cpp">struct FenwickTree {
    vector&lt;int&gt; bit;
    int n;

    // bit starts from index 1.
    FenwickTree(int n) : n(n), bit(n + 1) {}

    void update(int i, int delta) {
        // why ++i? Indices are 1-indexed internally.
        for (++i; i &lt;= n; i += i &amp; -i)
            bit[i] += delta;
    }

    int query(int i) {
        int sum = 0;
        for (++i; i &gt; 0; i -= i &amp; -i)
            sum += bit[i];
        return sum;
    }

    int rangeQuery(int l, int r) {
        return query(r) - (l ? query(l - 1) : 0);
    }
};
</code></pre>
<p>The trick <code>i &amp; -i</code> isolates the lowest set bit.</p>
<ul>
<li><code>i + (i &amp; -i)</code>: jump to next responsible index.</li>
<li><code>i - (i &amp; -i)</code>: jump to previous range.</li>
</ul>
<p>To be honest, even with so many hints, I find it is still hard to remember this
implementation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="policy-based-data-structures"><a class="header" href="#policy-based-data-structures">Policy-Based Data Structures</a></h1>
<p>Sometimes, we need a data structure that counts the number of integers greater
than a given value x and supports insertion. This mostly happen in a scenario
where you iterate through an array and calculate something for each element and
you would like the overall time complexity to be <code>O(NlogN)</code>. You may think of
using <code>std::set</code> or <code>std::multiset</code> as below.</p>
<pre><code class="language-cpp">std::set&lt;int&gt; s;
auto iter = set.lower_bound(x);
num = std::distance(iter, s.end());
</code></pre>
<p>This won't work as expected because <code>std::distance</code> has linear time complexity.</p>
<p>In order to make it <code>O(logN)</code>, we need some metadata attached to each tree
node. Support you will design it. What metadata you would attach? The size of
the subtree under each node, right? That is the exact idea of policy-based data
structures.</p>
<p>The most commonly used one is the below <code>pb_set</code> and <code>pb_map</code>. See example
below.</p>
<pre><code class="language-cpp">#include &lt;ext/pb_ds/assoc_container.hpp&gt;
#include &lt;ext/pb_ds/tree_policy.hpp&gt;
using namespace __gnu_pbds;

template&lt;class K&gt;
using pb_set = tree&lt;
    K,                        // key type
    null_type,                // mapped type (null for set)
    std::less&lt;K&gt;,             // comparator
    rb_tree_tag,              // underlying tree = red-black tree
    tree_order_statistics_node_update&gt;; // enables order stats

template&lt;class K, class V&gt;
using pb_map = tree&lt;
    K,
    V,
    std::less&lt;K&gt;,
    rb_tree_tag,
    tree_order_statistics_node_update&gt;;

int main() {
    pb_set&lt;int&gt; s;
    s.insert(1); s.insert(3); s.insert(5);
    for (int i = 0; i &lt;= 6; i++) cout &lt;&lt; s.order_of_key(i) &lt;&lt; endl;
    // output: 0 0 1 1 2 2 3
}
</code></pre>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<p>See the
<a href="https://github.com/gcc-mirror/gcc/blob/35e029530f256bb6302a3cae650d7eaef5514a36/libstdc++-v3/include/ext/pb_ds/tree_policy.hpp#L100">interface description</a>
and the implementation
<a href="https://github.com/gcc-mirror/gcc/blob/35e029530f256bb6302a3cae650d7eaef5514a36/libstdc++-v3/include/ext/pb_ds/detail/tree_policy/order_statistics_imp.hpp#L79">here</a>.
Basically, function <code>order_of_key</code> sums the metadata of all the left nodes of
the current node. The metadata is calculated in the <code>operator()(...)</code> function
which is the count of nodes in the subtree.</p>
<p>So we should expect <code>__gnu_pbds::tree&lt;...&gt;</code> should implement all <code>std::map</code>
methods, such as <code>insert</code>, <code>erase</code> and etc. But when I use it in practice, I
found it does not have <code>emplace(...)</code> method. What the hell! Since this is a
not a standardized container, this is totally possible. I decided to figure out
what interfaces it defines. With AI's help, I figure out almost all its methods
inherit from
<a href="https://github.com/gcc-mirror/gcc/blob/35e029530f256bb6302a3cae650d7eaef5514a36/libstdc++-v3/include/ext/pb_ds/detail/rb_tree_map_/rb_tree_.hpp#L84">rb_tree_map</a>.
Yes, the base class is determined by the tag you passed in the template.
<code>rb_tree_map</code> is a subclass of
<a href="https://github.com/gcc-mirror/gcc/blob/35e029530f256bb6302a3cae650d7eaef5514a36/libstdc++-v3/include/ext/pb_ds/detail/bin_search_tree_/bin_search_tree_.hpp#L109">bin_search_tree_map</a>.
<code>bin</code> means <code>binary</code>. Make sense. Red-black tree is a binary tree.</p>
<p>From <code>bin_search_tree_map</code>, it gets</p>
<ul>
<li><code>empty()</code></li>
<li><code>size()</code></li>
<li><code>max_size()</code>: Returns the maximum possible number of elements.</li>
<li><code>lower_bound(key)</code></li>
<li><code>upper_bound(key)</code></li>
<li><code>find(key)</code>: Finds an element with a specific key.</li>
<li><code>begin()</code></li>
<li><code>end()</code></li>
<li><code>rbegin()</code></li>
<li><code>rend()</code></li>
<li><code>clear()</code></li>
</ul>
<p>From <code>rb_tree_map</code> (the red-black tree specific operations), it gets</p>
<ul>
<li><code>insert(value)</code></li>
<li><code>operator[](key)</code></li>
<li><code>erase(key)</code> or <code>erase(iterator)</code></li>
<li><code>join(other_tree)</code>: Merges another tree into the current one.</li>
<li><code>split(key, other_tree)</code>: Splits the tree into two based on a key.</li>
</ul>
<p>Unfortunately, pb_ds is only implemented inside GCC/libstdc++. LLVM/libc++ does
not have it.</p>
<h2 id="which-to-choose-segment-tree-fenwick-tree-or-pb-ds"><a class="header" href="#which-to-choose-segment-tree-fenwick-tree-or-pb-ds">Which to choose, Segment Tree, Fenwick tree or PB-DS?</a></h2>
<p>All three options solve the similar problem. The TL;DR recommendations are
summarized in below table.</p>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Best Choice</th><th>Why</th></tr></thead><tbody>
<tr><td>Need <strong>count ≤ X</strong> or <strong>count &gt; X</strong> dynamically with arbitrary inserts</td><td><strong>PBDS</strong></td><td>Easiest, O(log N) both ways</td></tr>
<tr><td>Same need, but on macOS / LLVM (no PBDS)</td><td><strong>Fenwick Tree</strong></td><td>Works anywhere, just compress coordinates</td></tr>
<tr><td>Need <strong>range sums / updates</strong> on numeric ranges</td><td><strong>Segment Tree</strong></td><td>More flexible for numeric aggregations</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="trie"><a class="header" href="#trie">Trie</a></h1>
<p>Trie tree is easy to implement. See below sample code for lower case English
corps.</p>
<pre><code class="language-cpp">struct Node {
  shared_ptr&lt;Node&gt; next[26];
  int val = 0;
  Node() {}
};
using NodeP = shared_ptr&lt;Node&gt;;

NodeP root = make_shared&lt;Node&gt;();

void insert(const string&amp; word) {
  NodeP node = root;
  for (char c: word) {
    int idx = c - 'a';
    if (not node-&gt;next[idx]) node-&gt;next[idx] = make_shared&lt;Node&gt;();
    node = node-&gt;next[idx];
  }
  node-&gt;val = 1;
}
</code></pre>
<h2 id="optimizations"><a class="header" href="#optimizations">Optimizations</a></h2>
<p>The naive explicit tree structure using pointers is not cache friendly. One
optimization is to use an array to represent the tree. The <code>next</code> vector should
store the index of the next node in in the array. This was definitely not
invented by me. Checkout
<a href="https://cp-algorithms.com/string/aho_corasick.html">this reference</a>.</p>
<pre><code class="language-cpp">struct Node {
  int next[26], val = 0;
  Node() { fill_n(next, 26, -1); } // very important to explicitly initialize it.
};

vector&lt;Node&gt; trie(1); // the first element is the root

void insert(const string&amp; word) {
  int node = 0; // root at index 0.
  for (char c: word) {
    int idx = c - 'a';
    if (trie[node].next[idx] == -1) {
      trie[node].next[idx] = trie.size();
      trie.emplace_back(); // push the new node to the end of the array.
    }
    node = trie[node].next[idx];
  }
  trie[node].val = 1;
}
</code></pre>
<p>I asked chatgpt for more optimizations, and it suggests me that use a 2d array
<code>trie[n][next]</code> to go further with cache friendly. Too much for me!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="union-find"><a class="header" href="#union-find">Union-Find</a></h1>
<p>Read below beautiful one-liner implementation of the <code>find</code> function.</p>
<pre><code class="language-cpp">
vector&lt;int&gt; p; // fathers or parents
vector&lt;int&gt; ss; // size of each joint group.

int find(int i) {
    /*
    * If it itself is root, just return. If not, then find its real parent.
    * This part contains path compression because of the recursive call to
    * the `find` function.
    */
    return p[i] == i ? i : p[i] = find(p[i]);
}

void join(int i, int j, int cost) {
    int pi = find(i), pj = find(j);

    // this check is important. Otherwise, it updates group size which is wrong.
    if (pi != pj) {
        // Union by rank optimization - attaches smaller tree under larger one.
        if (ss[i] &gt; ss[j]) swap(pi, pj);
        p[pi] = pj;
        ss[pj] += ss[pi];
    }
}
</code></pre>
<h2 id="applications"><a class="header" href="#applications">Applications</a></h2>
<h3 id="cycle-detection"><a class="header" href="#cycle-detection">Cycle detection</a></h3>
<p>We can make the <code>join</code> function to return a boolean indicating the two nodes
are already joined or not. This trick can detect cycles in a graph.</p>
<h3 id="minimal-spanning-tree"><a class="header" href="#minimal-spanning-tree">Minimal Spanning Tree</a></h3>
<p>A minimum spanning tree (MST) or minimum weight spanning tree is a subset of
the edges of a connected, edge-weighted undirected graph that connects all the
vertices together, without any cycles and with the minimum possible total edge
weight.</p>
<p>Kruskal's algorithm uses Union-Find algorithm.</p>
<pre><code class="language-cpp">vector&lt;array&lt;int,3&gt;&gt; edges; // {weight, u, v}

// step 1: sort by weight
sort(edges.begin(), edges.end());


// step 2: Try to add each edge in order
// Here, we make a small change to the `join` function. It returns true if
// join happens, false if the two nodes are already joined.
long long mst = 0;
for (auto [w, u, v] : edges) {
    if (join(u, v)) mst += w;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lower_bound-and-upper_bound"><a class="header" href="#lower_bound-and-upper_bound">lower_bound and upper_bound</a></h1>
<p>These two functions/interfaces are very counter intuitive the first time I read
it. <code>lower_bound</code> means the position that is greater or equal than the target.
<code>upper_bound</code> means the position that is greater than the target. Actually,
<code>bound</code> means boundary. I should understand it as the half-open <strong>equal-range
boundaries</strong> <code>[lower_bound, upper_bound)</code>. Within this range, all elements are
equal to the target.</p>
<p>We have <code>std::lower_bound</code> and <code>map::lower_bound</code>. What are the differences?
The former is implemented
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/lower_bound.h#L30">here</a>.
The latter is implemented
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__tree#L2156">here</a>.</p>
<p><code>std::lower_bound</code> only requires <code>ForwardIterator</code>. The time complexity is
<code>O(logN)</code> for <code>RandomAccessIterator</code> but <code>O(NlogN)</code> for non random access
iterators because it uses <code>std::advance</code>. On the other hand, <code>map::lower_bound</code>
bisects to the left or right branch, so it is always <code>O(logN)</code>.</p>
<p><code>std::binary_search</code> is just a wrapper of <code>std::lower_bound</code>. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/binary_search.h#L27">code</a>.
It returns <code>__first != __last &amp;&amp; !__comp(__value, *__first)</code>, i.e., a boolean
whether the target is found or not.</p>
<h2 id="meta-binary-search"><a class="header" href="#meta-binary-search">Meta binary search</a></h2>
<p>One interesting thing I learnt from reading libc++ code is
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/lower_bound.h#L61">meta binary search</a>.
The idea is very similar to radix sort. You try out index <code>1xxxxx</code> first. If
the value at index <code>100...0</code> is larger than the target, then you to <code>0xxxxx</code>.
Otherwise, you go to the second significant bit <code>11xxxx</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kmp-knuthmorrispratt"><a class="header" href="#kmp-knuthmorrispratt">KMP (Knuth–Morris–Pratt)</a></h2>
<p>Given a long string S (text) and a short string W (pattern), find all positions
in S such that the substring starting from that position equals W. Let
<code>n = len(S)</code> and <code>m = len(W)</code>, then the brute-force solution has time
complexity <code>O(n*m)</code>.</p>
<h3 id="intuition"><a class="header" href="#intuition">Intuition</a></h3>
<p>Key points:</p>
<ol>
<li>
<p>Construct <code>lps</code> : longest proper prefix which is also a suffix.</p>
<p><code>lps[i]</code> = the longest proper prefix of <code>W[0..i]</code> which is also a suffix of
<code>W[0..i]</code>. proper prefix means it is prefix but not equal to itself.</p>
</li>
<li>
<p>The mismatched position is the crucial part.</p>
</li>
</ol>
<p>Let's simulation a case.</p>
<pre><code>i = current compare pos of S
j = current compare pos of W

01234567[8]90123456789012345 =&gt; S
    0123[4]56                =&gt; W
</code></pre>
<p>Above i = 8, j = 4, and we find <code>S[i] != W[j]</code>. What should we do?</p>
<p>For brute-force method, we simply shift W to right by one space and compare
from start again, namely,</p>
<pre><code>reset i = 5, j = 0.

01234[5]67890123456789012345 =&gt; S
     [0]123456               =&gt; W
</code></pre>
<p>Same for KMP, we need shift W to right, but the question is could we shift more
than one space? In this case, we already know that <code>S[4:7] = W[0:3]</code>. The
crucial part is that we should find a character in <code>W[0..x]</code> to compare <code>S[8]</code>.
We must have <code>x &lt; 4</code> since we will shift W to right. (Please think about this
part!) Suppose <code>x = 2</code></p>
<pre><code>01234567[8]90123456789012345 =&gt; S
      01[2]3456              =&gt; W
</code></pre>
<p>This configuration also means that <code>S[6:7]</code> = <code>W[0:1]</code>, but from about
<code>S[4:7] = W[0:3]</code>. So, we have <code>S[6:7] = W[0:1] = W[2:3]</code>, that is
<code>prefix = suffix</code>. In order to be conservative and not miss any possible
solution, we need x to be as large as possible, that is we need to find largest
proper <code>prefix = suffix</code>. That is <code>lps[i]</code>. Please draw the relation on a piece
of paper!</p>
<h3 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h3>
<p>Below Implementation is generated by Claude.ai. I explicitly ask him to make it
memorable. The key insight is that <strong>the same pattern works for both building
the LPS array and searching</strong>.</p>
<pre><code class="language-cpp">vector&lt;int&gt; kmp(const string&amp; text, const string&amp; pattern) {
    /******** Build LPS ********/
    int m = pattern.size();
    vector&lt;int&gt; lps(m);
    lsp[0] = 0; // why zero? Because it is proper prefix.

    // we start with i = 1, and in each iteration we guarantee to find lps[i].
    for (int i = 1, j=0; i &lt; m; i++) {
        // we the current character does not match, we move j to the last
        // longest proper prefix because the characters before that are guaranteed
        // to match and the move is conservative.
        while (j &gt; 0 &amp;&amp; pattern[i] != pattern[j]) j = lps[j - 1];

        // after the above loop, there are two possible outcome.
        // 1. pattern[i] == pattern[j] and j &gt;= 0. Note j could be zero in this case.
        // 2. pattern[i] != pattern[j] and j = 0. This case much have j = 0.
        if (pattern[i] == pattern[j]) j++;

        // for case #1, lsp[i] = (j - 0 + 1), but since we have j++ step above,
        // it becomes lsp[i] = j.
        // for case #2, j = 0, so lsp[i] = j = 0;
        lps[i] = j;
    }

    /******** Search ********/
    vector&lt;int&gt; matches;
    // For search, we start i, j both from zero.
    for (int i = 0, j = 0; i &lt; text.size(); i++) {
        while (j &gt; 0 &amp;&amp; text[i] != pattern[j]) j = lps[j - 1];
        if (text[i] == pattern[j]) j++;

        // when j==m, index of W goes out of range [0..m-1]
        // We can think of W[m] exits but definitely does not equal to S[i],
        // then we need assign j = lps[j-1].
        if (j == m) {
            matches.push_back(i - m + 1); // S[i-m+1, i] matches W.
            j = lps[j - 1];
        }
    }
    return matches;
}
</code></pre>
<p>The same pattern is as below.</p>
<pre><code>while j &gt; 0 and mismatch:
    j = lps[j - 1]
if match:
    j += 1
</code></pre>
<p>Memorization Tips:</p>
<ul>
<li>Two phases: Build LPS array, then search (same logic for both!).</li>
<li>Two pointers: <code>i</code> goes through text/pattern, <code>j</code> tracks match length.</li>
<li>On mismatch: Jump back using <code>j = lps[j - 1]</code> (keep doing this while
<code>j &gt; 0</code>).</li>
<li>On match: Just increment <code>j</code>.</li>
<li>Full match: When <code>j == len(pattern)</code>, you found it!</li>
</ul>
<p>What makes it "simple":</p>
<ul>
<li>No complex cases to handle.</li>
<li>The LPS building and searching use almost identical code.</li>
<li>Just ~15 lines of actual logic.</li>
</ul>
<h4 id="trick"><a class="header" href="#trick">Trick</a></h4>
<p>As you see above, the two stages are almost the same. We can have a trick to
write fewer lines of code. Suppose there is a character such as <code>$</code> that does
not show up in either the text corps nor the pattern, then we can create a new
string <code>{pattern}${text}</code> and build LPS for it. What does the result mean?</p>
<ol>
<li>The prefix is <code>{pattern}$</code>, and <code>$</code> does not show up anywhere else. This
means <code>lps[i] &lt;= len(pattern)</code>.</li>
<li>If <code>lps[i] == len(pattern)</code>, then <code>s[i-len(pattern)+1..i]</code> matches pattern.
So we just iterate <code>lps</code> to find all indices. Note, because we prefixed
<code>len(pattern) + 1</code> to the original string, then the correct substring range
should be <code>s[i-len(patthern)-1-len(pattern)+1..i-len(pattern)-1]</code>, which is
<code>s[i-2*len(pattern)..i-len(pattern)-1]</code></li>
</ol>
<pre><code class="language-cpp">vector&lt;int&gt; kmp(const string&amp; s, const string&amp; p) {
  string s2 = p + "$" + s;
  int n = s2.size();
  vector&lt;int&gt; lps(n);
  for (int i = 1, j = 0; i &lt; n; i++) {
    while (j &gt; 0 and s2[i] != s2[j]) j = lps[j-1];
    if (s2[i] == s2[j]) j++;
    lps[i] = j;
  }
  vector&lt;int&gt; matches;
  for (int i = 0; i &lt; n; i++) {
    if (lps[i] == p.size()) matches.push_back(i - 2*p.size());
  }
  return matches;
}
</code></pre>
<h3 id="complexity"><a class="header" href="#complexity">Complexity</a></h3>
<ul>
<li>time complexity: <code>O(n+m)</code>.</li>
<li>space complexity <code>O(m)</code>.</li>
</ul>
<p>We all agree that <code>i</code> increases exactly by one in each outer loop iteration.
But <code>j</code> can move forward and backward inside the inner loop. So why complexity
is <code>O(n+m)</code> but not <code>O(n*m)</code>? We need amortized analysis.</p>
<ul>
<li><code>j</code> can increase by at most 1 per iteration.</li>
<li><code>j</code> starts at 0, max value is m.</li>
<li>Total increases: at most n.</li>
<li>Total decreases: at most n (can't decrease more than it increased!).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boyermoore"><a class="header" href="#boyermoore">Boyer–Moore</a></h1>
<p>This is also a string matching algorithm. It has sublinear time complexity for
regular cases, but worse <code>O(n*m)</code> complexity, so it is frequently used in
practice, but not good for competitive programming. By the way, C++ 17 and
above has std implementation for Boyer-Moore search algorithm.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="z-algorithm"><a class="header" href="#z-algorithm">Z algorithm</a></h1>
<p>The Z-function (or Z-algorithm) is a string processing algorithm that computes,
for each position in a string, the length of the longest substring starting at
that position which is also a prefix of the string. Given a string <code>s</code> of
length <code>n</code>, the Z-function of <code>s</code> is an array <code>Z</code> of length n where:</p>
<pre><code>Z[i] = max k such that s[0..k-1] == s[i..i+k-1]
</code></pre>
<p>This reminds me about the longest proper prefix suffix array in KMP.</p>
<p>I send below prompt to claude.ai.</p>
<blockquote>
<p>could you do an animation of z-algorithm with details about the definitions
of Z box and how it is updated?</p>
</blockquote>
<p>And it generated beautiful animation and detailed explanation. Below content is
mostly copied from claude. It summarizes better than me.</p>
<h2 id="what-is-the-z-box-l-r"><a class="header" href="#what-is-the-z-box-l-r">What is the Z-Box [L, R]?</a></h2>
<p>The Z-box is an interval <code>[L, R]</code> representing the <strong>rightmost</strong> segment of the
string where:</p>
<ul>
<li><code>s[L..R]</code> exactly matches <code>s[0..R-L]</code> (a prefix of the string).</li>
<li><code>R</code> is as large as possible (rightmost such segment we've found).</li>
<li>It helps us avoid redundant character comparisons.</li>
</ul>
<p>Two Main Cases:</p>
<ul>
<li>
<p>Case 1: <code>i &gt; R</code> (Outside the Z-box)</p>
<p>Position i is beyond our known matching segment. We must compare characters
from scratch to compute <code>Z[i]</code>, then update the Z-box to <code>[i, i+Z[i]-1]</code>.</p>
</li>
<li>
<p>Case 2: <code>i ≤ R</code> (Inside the Z-box)</p>
<p>Position i falls within <code>[L, R]</code>. We use the "mirror" position <code>k = i - L</code>.
Since <code>s[L..R]</code> matches <code>s[0..R-L]</code>, we know <code>s[i..R]</code> corresponds to
<code>s[k..R-L]</code>.</p>
<ul>
<li>
<p>Case 2a: <code>Z[k] &lt; r - i + 1</code></p>
<p>The match at k is fully contained. Simply copy: <code>Z[i] = Z[k]</code>. Z-box
unchanged.</p>
</li>
<li>
<p>Case 2b: <code>Z[k] ≥ r - i + 1</code></p>
<p>The match might extend beyond <code>R</code>. We know it matches up to <code>R</code>, but must
compare beyond to see how far it extends. Update Z-box to <code>[i, new_R]</code>.</p>
</li>
</ul>
</li>
</ul>
<p>The core intuition of Z algorithm is "rightmost"! There are a few invariants.
When we process index <code>i</code>, we must have <code>i &gt; L</code>, and <code>R &gt;= L - 1</code>. The
<code>R == L - 1</code> case corresponds to Z value being 0. Remember we use a close range
<code>[L, R]</code>.</p>
<h2 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h2>
<pre><code class="language-cpp">vector&lt;int&gt; compute_z_array(const string&amp; s) {
  int n = s.size();
  vector&lt;int&gt; Z(n); // Z[0] = 0 by tradition.

  int l = 0, r = 0; // Z-box [l, r]
  for (int i = 1; i &lt; n; i++) {
    if (i &gt; r) { // case 1.
      l = r = i;
      int tmp = 0;
      while (r &lt; n and s[r] == s[tmp++]) r++;
      Z[i] = --r - l + 1; // we need --r because it goes one index beyond.
    } else { // case 2.
      // s[i..r] == s[i-l, r-l] == s[k, r-l]
      int k = i - l;
      if (Z[k] &lt; r-i+1) Z[i] = Z[k];
      else {
        // in this case, we find a even more right range staring at i,
        // and s[i..r] == s[0, r-i], and there is potential to extend it.
        l = i;
        // node predefine tmp to r-i avoids bugs because below code updates r.
        int tmp = r-i;
        while (r &lt; n and s[r] == s[tmp++]) r++;
        Z[i] = --r - l + 1;
      }
    }
  }
  return Z;
}
</code></pre>
<h2 id="complexity-1"><a class="header" href="#complexity-1">Complexity</a></h2>
<ul>
<li>time complexity: <code>O(n)</code>. The Z-box boundary R only moves to the right (never
left). Each character comparison either increases R or we're done with that
position. Since R can increase at most n times, total comparisons = <code>O(n)</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hash"><a class="header" href="#hash">Hash</a></h1>
<p>Types supported by std::hash:</p>
<ul>
<li>
<p>all integral types: bool, int, float, enum, etc</p>
</li>
<li>
<p><code>std::string</code>: It uses murmur hash.</p>
</li>
<li>
<p>Raw pointer: hash the address. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__functional/hash.h#L332">code</a>.</p>
<p>This basically means below code <code>h(&amp;a)</code> and <code>h(&amp;b)</code> return different values.</p>
<pre><code>struct MyClass {};
MyClass a, b;
std::hash&lt;MyClass*&gt; h;
</code></pre>
</li>
<li>
<p><code>std::unique_ptr</code>: hash the address. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__memory/unique_ptr.h#L802">code</a>.
This is similar to raw pointer.</p>
</li>
<li>
<p><code>std::optional</code>: hash the value if present or just return zero. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/optional#L1278">code</a>.</p>
</li>
<li>
<p><code>std::variant</code>: combine hash of the value and index. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/variant#L1606">code</a>.
This makes sense because union types only has one correct view. It is
essentially the same as the backing type. But, not sure why we combine the
index information. To distinguish the two possibilities of
<code>variant&lt;int, int&gt;</code>? Wait. This is not even a valid variant.</p>
</li>
</ul>
<p>It does not support <code>vector</code> in general, but has a specialization for
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__vector/vector_bool.h#L1095">vector<bool></a>.
What the hell!</p>
<h2 id="combine-hash"><a class="header" href="#combine-hash">Combine hash</a></h2>
<p>For non-supported types, we need to write the hash function by ourselves. It is
usually an art of combining hashes. See below example for <code>std::pair</code>.</p>
<pre><code class="language-cpp">class HashPair {

  template&lt;class A, class B&gt;
  size_t operator()(const pair&lt;A, B&gt;&amp; p) const {
    return std::hash&lt;A&gt;{}(p.first) ^ (std::hash&lt;B&gt;{}(p.second) &lt;&lt; 1);
  }
};
</code></pre>
<h3 id="why-h1--h2--1"><a class="header" href="#why-h1--h2--1">Why <code>h1 ^ (h2 &lt;&lt; 1)</code>?</a></h3>
<p>Why XOR? Among the three simplest bit operator AND, OR and XOR, XOR's result is
evenly distributed. For example, for the 4 combinations of <code>0</code>, <code>1</code>, the XOR's
result has two <code>0</code>s and two <code>1</code>s. AND produces one <code>1</code> and three <code>0</code>s. OR
produces three <code>1</code>s, and one <code>0</code>.</p>
<p>Why left shift? It makes order sensitive, so <code>hash(a, b) != hash(b, a)</code>.</p>
<h2 id="how-is-hash-requirement-enforced"><a class="header" href="#how-is-hash-requirement-enforced">How is hash requirement enforced?</a></h2>
<p>Some of them uses
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__functional/hash.h#L537">__enable_hash_helper</a>.
It requires all key types to be hashable.</p>
<p>Some of them put it in the destructor. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/unordered_set#L1337">example</a>.
Why?</p>
<p>Below is AI's response.</p>
<ol>
<li>
<p>Incomplete Types at Instantiation: When you instantiate a class template
like std::unordered_set<MyType>, MyType can be an incomplete type at that
point. An incomplete type is a type that has been declared but not yet
fully defined (e.g., class MyType;). You can have pointers and references
to incomplete types, but you can't know their size or access their members.</p>
</li>
<li>
<p><code>static_assert</code> Requires Complete Types: A static_assert that inspects the
properties of a type (like checking if it's copy-constructible or if it has
a specific function call operator) requires the type to be complete. If the
static_assert were placed at the top of the unordered_set class definition,
it would be checked as soon as you write std::unordered_set<MyType>. If
MyType is incomplete at that point, the compilation would fail, even if
MyType is defined later in the same file.</p>
</li>
<li>
<p>Delayed Instantiation of the Destructor: The body of a class template's
member function (including the destructor) is not instantiated until it is
actually used or explicitly instantiated. By placing the static_assert in
the destructor, the check is delayed until the point where an unordered_set
object is actually destroyed. By that time, any template arguments that
were incomplete types must have been completed.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="math"><a class="header" href="#math">Math</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utility-functions"><a class="header" href="#utility-functions">Utility Functions</a></h1>
<h2 id="gcd-greatest-common-divisor-and-lcm-least-common-multiplier"><a class="header" href="#gcd-greatest-common-divisor-and-lcm-least-common-multiplier">GCD (Greatest Common Divisor) and LCM (Least Common Multiplier)</a></h2>
<p>Both <code>std::gcd</code> and <code>std::lcm</code> were introduced in c++17, so most time, you do
not need to implement them by themself. However, for reference, see below
one-liner implementation for <code>gcd</code>.</p>
<pre><code class="language-cpp">int gcd(int a, int b) { return a == 0 ? b : gcd(b%a, a); };
</code></pre>
<p>Also, in some case, we need overflow protection, we can have below <code>lcm</code>
implementation.</p>
<pre><code class="language-cpp">using ll = long long;
ll lcm(ll a, ll b, ll limit) {
    int gcd = std::gcd(a, b);
    if (a / gcd &gt; limit / b) return limit + 1; // return a number larger than limit indicating overflow.
    return a / gcd * b;
}
</code></pre>
<h2 id="binomial-coefficients-without-overflow"><a class="header" href="#binomial-coefficients-without-overflow">Binomial Coefficients Without Overflow</a></h2>
<p>I asked this question to claude.ai, and it gives me quite a few good
approaches. Here, I just list the exact Multiplicative Formula approach.</p>
<pre><code class="language-cpp">long long binomial(int n, int k) {
    if (k &gt; n - k) k = n - k;  // Symmetry

    long long result = 1;
    for (int i = 0; i &lt; k; i++) {
        result = result * (n - i) / (i + 1);
    }
    return result;
}
</code></pre>
<p>You may wonder why <code>result * (n-i)</code> is divisible by <code>i+1</code>. This is because
<code>C(n, k+1) = C(n, k) * (n-k) / (k+1)</code> which is guaranteed to be divisible.</p>
<h2 id="all-dividends"><a class="header" href="#all-dividends">All dividends</a></h2>
<p>Not all problems require linear or <code>log(N)</code> complexity, some math problems can
have a complexity factor of <code>sqrt(N)</code>. All dividends is one of them.</p>
<pre><code class="language-cpp">unordred_set&lt;int&gt; dividents(int x) {
  unordred_set&lt;int&gt; ans;
  for (int i = 1; i * i &lt;= x; i++) {
    if (x % i != 0) continue;
    ans.insert(i);
    ans.insert(x/i);
  }
  return ans;
}
</code></pre>
<h2 id="harmonic-series"><a class="header" href="#harmonic-series">Harmonic Series</a></h2>
<p>This is related to all dividends, some math problem may have complexity
<code>N + N/2 + N/3 + .. + N/N</code>. This is called [Harmonic
Series](https://en.wikipedia.org/wiki/Harmonic_series_(mathematics) which has
complexity <code>log(N)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inclusion-exclusion-principle"><a class="header" href="#inclusion-exclusion-principle">Inclusion-Exclusion Principle</a></h1>
<p>The problem statement:</p>
<pre><code>Goal: Count elements in A₁ ∪ A₂ ∪ ... ∪ Aₙ

Formula: |A₁ ∪ ... ∪ Aₙ| =
  Σ(single sets) - Σ(pairs) + Σ(triples) - ... + (-1)^(n+1) Σ(all n)
</code></pre>
<p>This formula looks daunting in the first appearance. How could you enumerate
all these combinations? It is definitely extremely hard in the general case.
However, in competitive programming context, <code>n</code> is usually less than <code>32</code>, so
we can use bit mask to enumerate the set. The pseudocode is what follows.</p>
<pre><code class="language-cpp">// Input: vector&lt;int&gt; A =&gt; represent the array we need apply some count on it.

int n = A.size();
int total = 0;

for (int mask = 1; mask &lt; (1&lt;&lt;n); mask++) {
    int bits = 0; // number of element in the set.
    for (int i = 0; i &lt; n; i++) {
        if ((1&lt;&lt;i) &amp; mask) {
            // A[i] is chosen, do the counting here.
            ...

            // Also, do not forget count included elements.
            bits++;
        }
    }
    cout == ... // business logic related

    // Inclusion-exclusion: odd size adds, even size subtracts
    if (bits % 2 == 1) {
        total += count;
    } else {
        total -= count;
    }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
