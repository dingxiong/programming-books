<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>All I know about C++</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/code-details.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">All I know about C++</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book contains all I know about C++: standard drafts, compiler
implementation, data structures, algorithms, competitive programming skills and
etc.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="comparator"><a class="header" href="#comparator">Comparator</a></h1>
<p><code>std::sort</code> can pass a <code>comp</code> parameter at the end. If not specified, then it
is defaults to
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/sort.h#L967">std::less</a>.</p>
<p>Sometimes, we want to sort nested containers, then how comparison works for
them.</p>
<p>For vector, it is defined as
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__vector/comparison.h#L49">std::lexicographical_compare</a>.
Basically, it compares element by element until a different one is found or one
vector goes out of range. In the latter case, the short vector is smaller.
<code>std:string</code>, <code>std::deque</code>, <code>std::array</code> <code>std::pair</code> and <code>std::tuple</code> are
similar to vector. They compare from the first element. If equal, then the
second, and the rest.</p>
<p><code>std::set</code> and <code>set::map</code> define <code>operator&lt;</code> as well. It is lexicographical
order as well. However, <code>std::unordered_set</code> and <code>std::unordered_map</code> only
define <code>operator==</code> and <code>operator!=</code>.</p>
<p>Comparator is also used extensively in sorted containers. <code>std::set</code> and
<code>std::map</code> has comparator template argument. There is a caveat that</p>
<blockquote>
<p>Everywhere the standard library uses the Compare requirements, uniqueness is
determined by using the equivalence relation. In imprecise terms, two objects
a and b are considered equivalent if neither compares less than the other:
!comp(a, b) &amp;&amp; !comp(b, a).</p>
</blockquote>
<p>The concrete code is
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__tree#L1705">here</a>.
Both <code>set</code> and <code>map</code> are implemented using red-black tree. When inserting a new
element, The case <code>not a &lt; b and not b &lt; a</code> means two keys are equal. If you
forget tie breaker, then you may end up with a undetermined behavior. For
example, in Dijkstra shortest path algorithm, we should define the comparator
as</p>
<pre><code class="language-cpp">auto comp = [&amp;distances](const string &amp;a, const string &amp;b) {
    if (distances[a] != distances[b])
        return distances[a] &lt; distances[b];
    return a &lt; b;
};
</code></pre>
<h1 id="radix-sort"><a class="header" href="#radix-sort">Radix Sort</a></h1>
<p>libc++ has a good demonstration of the usage of radix sort. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/stable_sort.h#L256">code</a>.</p>
<p>First, it is only used if the container value type is integral. It works for
int32, int64, etc but not floats, strings. Also, it supports negative integrals
as well. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/radix_sort.h#L298">code</a>.
Using int8 as an example, the trick <code>numeric_limits&lt;_Ip&gt;::min() ^ value</code> can be
explained by below table.</p>
<pre><code>┌───────────────────┬───────────────────────┬──────────────────────────┬───────────────────┐
│ Original (Signed) │ Binary Representation │ XOR with -128 (10000000) │ Result (Unsigned) │
├───────────────────┼───────────────────────┼──────────────────────────┼───────────────────┤
│ -128              │ 10000000              │ 10000000 ^ 10000000      │ 00000000 (0)      │
│ -127              │ 10000001              │ 10000001 ^ 10000000      │ 00000001 (1)      │
│ -1                │ 11111111              │ 11111111 ^ 10000000      │ 01111111 (127)    │
│ 0                 │ 00000000              │ 00000000 ^ 10000000      │ 10000000 (128)    │
│ 1                 │ 00000001              │ 00000001 ^ 10000000      │ 10000001 (129)    │
│ 127               │ 01111111              │ 01111111 ^ 10000000      │ 11111111 (255)    │
└───────────────────┴───────────────────────┴──────────────────────────┴───────────────────┘
</code></pre>
<p>It maps <code>[-128, 127]</code> to <code>[0, 255]</code> without changing the relative order.</p>
<p>Second, in the competitive coding context, most people will do radix sorting by
comparing the decimal digits, but libc++
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/radix_sort.h#L306">compares bytes</a>.</p>
<p>Third, radix sorting uses counting sort. The basic idea is counting the digit
occurrence and do a prefix sum, so we know the position in the sorted array
given a digit. The caveat is to maintain the stable order. If two numbers have
the same digit, their relative order should not change. The pseudocode is</p>
<pre><code class="language-cpp">void counting_sort(vector&lt;int&gt;&amp; arr, int exp) {
    int n = arr.size();
    vector&lt;int&gt; output(n), count(10, 0);

    // frequency prefix sum.
    for (int i = 0; i &lt; n; i++) count[(arr[i] / exp) % 10]++;
    for (int i = 1; i &lt; 10; i++) count[i] += count[i - 1];

    // start from the right end and decrease the frequency so we can maintain
    // stable order.
    for (int i = n - 1; i &gt;= 0; i--) {
        int digit = (arr[i] / exp) % 10;
        output[count[digit] - 1] = arr[i];
        count[digit]--;
    }
    arr = output;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="priority-queue"><a class="header" href="#priority-queue">Priority Queue</a></h1>
<p>I do not like <code>std::priority_queue</code> because it does not provide the <code>begin</code> nor
<code>end</code> iterator. Later on, I learned a set of functions to deal with max heap
directly: <code>make_heap</code>, <code>push_heap</code> and <code>pop_heap</code>. I am very happy with it
because it allows me implementing priority queue on top of vector, and I can
iterate vector! Then I suspect the push/pop operation of <code>std::priority_queue</code>
is just a wrapper of <code>push_heap</code>/<code>pop_heap</code>. It is! See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/queue#L899">code</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-vs-graph"><a class="header" href="#tree-vs-graph">Tree vs Graph</a></h1>
<p>A tree is an undirected, connected, and acyclic graph. It has <code>n</code> nodes, <code>n-1</code>
edges and is fully connected. This setup often shows up in competitive
programming.</p>
<p>Realizing it is a tree is helpful for DFS because often times the graph
definition contains not only the child nodes but also the parent node. A simple
trick to skip going back is</p>
<pre><code class="language-cpp">for (next : graph[node]):
    if (next == parent_node) continue
</code></pre>
<h1 id="segment-tree"><a class="header" href="#segment-tree">Segment Tree</a></h1>
<p>A few conventions to reduce chances of mistakes.</p>
<ol>
<li>left branch is <code>[l, m]</code>, right branch is <code>[m+1, r]</code>. This avoids the index
of out of range error for the middle point <code>(l+r)/2</code>.</li>
</ol>
<p>Below is the naive implementation using explicit tree node.</p>
<details class="code-details">
<summary> struct Node; </summary>
<pre><code class="language-cpp">struct Node {
    int l, r;
    shared_ptr&lt;Node&gt; left, right;
    int s; // each node stores the sum of the range [l,r].
    Node(int l, int r): l(l), r(r), s(0) {}
};
using NodeP = shared_ptr&lt;Node&gt;;

NodeP root;

void create_children(NodeP node) {
     if (node-&gt;l != node-&gt;r) {
        int m = (node-&gt;l + node-&gt;r) / 2;
        if (not node-&gt;left) node-&gt;left = make_shared&lt;Node&gt;(node-&gt;l, m);
        if (not node-&gt;right) node-&gt;right = make_shared&lt;Node&gt;(m+1, node-&gt;r);
    }
}

int query(NodeP node, int l, int r) {
    int m = (node-&gt;l + node-&gt;r) / 2;
    create_children(node);
    if (node-&gt;l == l and node-&gt;r == r) {
        return node-&gt;s;
    }

    if (r &lt;= m) return search(node-&gt;left, l, r);
    else if (l &gt; m) return search(node-&gt;right, l, r);
    else return search(node-&gt;left, l, m) + search(node-&gt;right, m+1, r);
}

// Add val to the existing value at node i.
void update(NodeP node, int i, int val) {
  create_children();
  node-&gt;s += val;
  if (node-&gt;l == i and node-&gt;r == i) return;
  int m = (node-&gt;l + node-&gt;r) / 2;
  if (i &lt;= m) update(node-&gt;left, i, val);
  else update(node-&gt;right, i, val);
}
</code></pre>
</details>
<p>Most segment tree code you see online uses an array to represent the tree. See
<a href="https://www.hackerearth.com/practice/notes/segment-tree-and-lazy-propagation/">example</a>.
An array <code>int tree[2n+1]</code> represent a tree with <code>n</code> nodes. <code>tree[k]</code> has
children <code>tree[2k]</code> and <code>tree[2k+1]</code>. Root node is <code>tree[1]</code>. However, I do not
like this implementation because it makes the interface more verbose. In my
implementation, <code>struct Node</code> contains the boundary information <code>l</code> and <code>r</code>.
With the array approach, the interface becomes
<code>int query(int node, int start, int end, int l, int r)</code>. The first 3 parameters
are the node index, left and right boundary.</p>
<h2 id="lazy-propagation"><a class="header" href="#lazy-propagation">Lazy Propagation</a></h2>
<p>The basic search and update operation has <code>O(logN)</code> complexity. It is not
efficient for range update. To make it <code>O(logN)</code> as well, we need lazy
propagation. A new helper <code>push</code> introduced. It realized the laziness at the
current node, and push the laziness down to its children. There are four places
we need <code>push</code>. First, at the beginning of a query, which is obvious. Then 3
places in <code>update</code>:</p>
<ol>
<li>At the beginning of <code>update</code>.</li>
<li>At the base condition, i.e., query range equals node's boundary. This is
where the performance improvement comes from. It avoids going deep to leaf
nodes, and simply put a marker in the current node saying: all nodes under
this subtree have an un-realized update amount <code>inc_amount</code>.</li>
<li>Before we finally update current node's value. This is pre-order traversal.
We need to make sure the left and right children do not have any lazy value
before we add them up. Otherwise, it would be wrong. This is most popular
mistake I made!</li>
</ol>
<details class="code-details">
<summary> Lazy Propagation </summary>
<pre><code class="language-cpp">struct Node {
    int l, r;
    shared_ptr&lt;Node&gt; left, right;
    int lazy = 0; // lazy update amount
    int s;
    Node(int l, int r): l(l), r(r), s(0) {}
};
using NodeP = shared_ptr&lt;Node&gt;;

NodeP root;

void create_children(NodeP node) {
     if (node-&gt;l != node-&gt;r) {
        int m = (node-&gt;l + node-&gt;r) / 2;
        if (not node-&gt;left) node-&gt;left = make_shared&lt;Node&gt;(node-&gt;l, m);
        if (not node-&gt;right) node-&gt;right = make_shared&lt;Node&gt;(m+1, node-&gt;r);
    }
}

// realize laziness at current node and push it down the tree.
void push(NodeP node) {
    if (node-&gt;lazy) {
        node-&gt;s += node-&gt;lazy * (node-&gt;r - node-&gt;l + 1);
        // only push down when it is not a leaf node.
        if (node-&gt;l != node-&gt;r) {
            node-&gt;left-&gt;lazy += node-&gt;lazy;
            node-&gt;right-&gt;lazy += node-&gt;lazy;
        }
        // remember to reset laziness.
        node-&gt;lazy = 0;
    }
}

int query(NodeP node, int l, int r) {
    int m = (node-&gt;l + node-&gt;r) / 2;
    create_children(node);
    // realize laziness before query.
    push(node);
    if (node-&gt;l == l and node-&gt;r == r) {
        return node-&gt;s;
    }

    if (r &lt;= m) return search(node-&gt;left, l, r);
    else if (l &gt; m) return search(node-&gt;right, l, r);
    else return search(node-&gt;left, l, m) + search(node-&gt;right, m+1, r);
}

void update(NodeP node, int l, int r, int inc_amount) {
    int m = (node-&gt;l + node-&gt;r) / 2;
    create_children(node);
    push(node);

    if (node-&gt;l == l and node-&gt;r == r) {
        node-&gt;lazy += inc_amount;
        push(node);
        return;
    }
    if (r &lt;= m) {
        insert(node-&gt;left, l, r);
    } else if (l &gt; m) {
        insert(node-&gt;right, l, r);
    } else {
        insert(node-&gt;left, l, m);
        insert(node-&gt;right, m+1, r);
    }
    // make sure left and right do not have un-realized updates.
    push(node-&gt;left); push(node-&gt;right);
    node-&gt;s = node-&gt;left-&gt;s + node-&gt;right-&gt;s;
}
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lower_bound-and-upper_bound"><a class="header" href="#lower_bound-and-upper_bound">lower_bound and upper_bound</a></h1>
<p>These two functions/interfaces are very counter intuitive the first time I read
it. <code>lower_bound</code> means the position that is greater or equal than the target.
<code>upper_bound</code> means the position that is greater than the target. Actually,
<code>bound</code> means boundary. I should understand it as the half-open <strong>equal-range
boundaries</strong> <code>[lower_bound, upper_bound)</code>. Within this range, all elements are
equal to the target.</p>
<p>We have <code>std::lower_bound</code> and <code>map::lower_bound</code>. What are the differences?
The former is implemented
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/lower_bound.h#L30">here</a>.
The latter is implemented
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__tree#L2156">here</a>.</p>
<p><code>std::lower_bound</code> only requires <code>ForwardIterator</code>. The time complexity is
<code>O(logN)</code> for <code>RandomAccessIterator</code> but <code>O(NlogN)</code> for non random access
iterators because it uses <code>std::advance</code>. On the other hand, <code>map::lower_bound</code>
bisects to the left or right branch, so it is always <code>O(logN)</code>.</p>
<p><code>std::binary_search</code> is just a wrapper of <code>std::lower_bound</code>. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/binary_search.h#L27">code</a>.
It returns <code>__first != __last &amp;&amp; !__comp(__value, *__first)</code>, i.e., a boolean
whether the target is found or not.</p>
<h2 id="meta-binary-search"><a class="header" href="#meta-binary-search">Meta binary search</a></h2>
<p>One interesting thing I learnt from reading libc++ code is
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/lower_bound.h#L61">meta binary search</a>.
The idea is very similar to radix sort. You try out index <code>1xxxxx</code> first. If
the value at index <code>100...0</code> is larger than the target, then you to <code>0xxxxx</code>.
Otherwise, you go to the second significant bit <code>11xxxx</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kmp-knuthmorrispratt"><a class="header" href="#kmp-knuthmorrispratt">KMP (Knuth–Morris–Pratt)</a></h2>
<p>Given a long string S (text) and a short string W (pattern), find all positions
in S such that the substring starting from that position equals W. Let
<code>n = len(S)</code> and <code>m = len(W)</code>, then the brute-force solution has time
complexity <code>O(n*m)</code>.</p>
<h3 id="intuition"><a class="header" href="#intuition">Intuition</a></h3>
<p>Key points:</p>
<ol>
<li>
<p>Construct <code>lps</code> : longest proper prefix which is also a suffix.</p>
<p><code>lps[i]</code> = the longest proper prefix of <code>W[0..i]</code> which is also a suffix of
<code>W[0..i]</code>. proper prefix means it is prefix but not equal to itself.</p>
</li>
<li>
<p>The mismatched position is the crucial part.</p>
</li>
</ol>
<p>Let's simulation a case.</p>
<pre><code>i = current compare pos of S
j = current compare pos of W

01234567[8]90123456789012345 =&gt; S
    0123[4]56                =&gt; W
</code></pre>
<p>Above i = 8, j = 4, and we find <code>S[i] != W[j]</code>. What should we do?</p>
<p>For brute-force method, we simply shift W to right by one space and compare
from start again, namely,</p>
<pre><code>reset i = 5, j = 0.

01234[5]67890123456789012345 =&gt; S
     [0]123456               =&gt; W
</code></pre>
<p>Same for KMP, we need shift W to right, but the question is could we shift more
than one space? In this case, we already know that <code>S[4:7] = W[0:3]</code>. The
crucial part is that we should find a character in <code>W[0..x]</code> to compare <code>S[8]</code>.
We must have <code>x &lt; 4</code> since we will shift W to right. (Please think about this
part!) Suppose <code>x = 2</code></p>
<pre><code>01234567[8]90123456789012345 =&gt; S
      01[2]3456              =&gt; W
</code></pre>
<p>This configuration also means that <code>S[6:7]</code> = <code>W[0:1]</code>, but from about
<code>S[4:7] = W[0:3]</code>. So, we have <code>S[6:7] = W[0:1] = W[2:3]</code>, that is
<code>prefix = suffix</code>. In order to be conservative and not miss any possible
solution, we need x to be as large as possible, that is we need to find largest
proper <code>prefix = suffix</code>. That is <code>lps[i]</code>. Please draw the relation on a piece
of paper!</p>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<p>Below Implementation is generated by Claude.ai. I explicitly ask him to make it
memorable. The key insight is that <strong>the same pattern works for both building
the LPS array and searching</strong>.</p>
<pre><code class="language-cpp">vector&lt;int&gt; kmp(const string&amp; text, const string&amp; pattern) {
    /******** Build LPS ********/
    int m = pattern.size();
    vector&lt;int&gt; lps(m);
    lsp[0] = 0; // why zero? Because it is proper prefix.

    // we start with i = 1, and in each iteration we guarantee to find lps[i].
    for (int i = 1, j=0; i &lt; m; i++) {
        // we the current character does not match, we move j to the last
        // longest proper prefix because the characters before that are guaranteed
        // to match and the move is conservative.
        while (j &gt; 0 &amp;&amp; pattern[i] != pattern[j])
            j = lps[j - 1];

        // after the above loop, there are two possible outcome.
        // 1. pattern[i] == pattern[j] and j &gt;= 0. Note j could be zero in this case.
        // 2. pattern[i] != pattern[j] and j = 0. This case much have j = 0.
        if (pattern[i] == pattern[j])
            j++;

        // for case #1, lsp[i] = (j - 0 + 1), but since we have j++ step above,
        // it becomes lsp[i] = j.
        // for case #2, j = 0, so lsp[i] = j = 0;
        lps[i] = j;
    }

    /******** Search ********/
    vector&lt;int&gt; matches;
    // For search, we start i, j both from zero.
    for (int i = 0, j = 0; i &lt; text.size(); i++) {
        while (j &gt; 0 &amp;&amp; text[i] != pattern[j])
            j = lps[j - 1];
        if (text[i] == pattern[j])
            j++;

        // when j==m, index of W goes out of range [0..m-1]
        // We can think of W[m] exits but definitely does not equal to S[i],
        // then we need assign j = lps[j-1].
        if (j == m) {
            matches.push_back(i - m + 1); // S[i-m+1, i] matches W.
            j = lps[j - 1];
        }
    }
    return matches;
}
</code></pre>
<p>The same pattern is as below.</p>
<pre><code>while j &gt; 0 and mismatch:
    j = lps[j - 1]
if match:
    j += 1
</code></pre>
<p>Memorization Tips:</p>
<ul>
<li>Two phases: Build LPS array, then search (same logic for both!).</li>
<li>Two pointers: <code>i</code> goes through text/pattern, <code>j</code> tracks match length.</li>
<li>On mismatch: Jump back using <code>j = lps[j - 1]</code> (keep doing this while
<code>j &gt; 0</code>).</li>
<li>On match: Just increment <code>j</code>.</li>
<li>Full match: When <code>j == len(pattern)</code>, you found it!</li>
</ul>
<p>What makes it "simple":</p>
<ul>
<li>No complex cases to handle.</li>
<li>The LPS building and searching use almost identical code.</li>
<li>Just ~15 lines of actual logic.</li>
</ul>
<h3 id="complexity"><a class="header" href="#complexity">Complexity</a></h3>
<ul>
<li>time complexity: <code>O(n+m)</code>.</li>
<li>space complexity <code>O(m)</code>.</li>
</ul>
<p>We all agree that <code>i</code> increases exactly by one in each outer loop iteration.
But <code>j</code> can move forward and backward inside the inner loop. So why complexity
is <code>O(n+m)</code> but not <code>O(n*m)</code>? We need amortized analysis.</p>
<ul>
<li><code>j</code> can increase by at most 1 per iteration.</li>
<li><code>j</code> starts at 0, max value is m.</li>
<li>Total increases: at most n.</li>
<li>Total decreases: at most n (can't decrease more than it increased!).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boyermoore"><a class="header" href="#boyermoore">Boyer–Moore</a></h1>
<p>This is also a string matching algorithm. It has sublinear time complexity for
regular cases, but worse <code>O(n*m)</code> complexity, so it is frequently used in
practice, but not good for competitive programming. By the way, C++ 17 and
above has std implementation for Boyer-Moore search algorithm.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
