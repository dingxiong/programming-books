<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>All I know about C++</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/code-details.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">All I know about C++</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book contains all I know about C++: standard drafts, compiler
implementation, data structures, algorithms, competitive programming skills and
etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-standards"><a class="header" href="#c-standards">C++ Standards</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="9-declarations"><a class="header" href="#9-declarations">9 Declarations</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initializers"><a class="header" href="#initializers">Initializers</a></h1>
<p>Initialization in C++ is complicated. See
<a href="https://eel.is/c++draft/dcl.init">C++ standard</a>. If you believe you are an
expert in this area, then please answer the below questions.</p>
<ol>
<li>For <code>int arr[5];</code>, are all 5 elements initialized to zero?</li>
<li>How about <code>int arr[5] = {};</code>?</li>
<li>How about <code>int arr[5] = {1};</code>?</li>
<li>For <code>vector&lt;int&gt; v(5);</code>, are all 5 elements initialized to zero?</li>
<li>How about <code>vector&lt;pair&lt;int, int&gt;&gt; v(5);</code>?</li>
</ol>
<p>We need to cover at least concepts: <code>default initialization</code>,
<code>zero initialization</code> and <code>value initialization</code>.</p>
<h2 id="value-initialization"><a class="header" href="#value-initialization">Value Initialization</a></h2>
<p><a href="https://eel.is/c++draft/dcl.init#general-9">dcl.init#general-9</a> covers value
initialization. It covers 3 cases: class type, array type and others.</p>
<h3 id="others"><a class="header" href="#others">Others</a></h3>
<p>Let's see the others' case. The standard draft says</p>
<blockquote>
<p>Otherwise, the object is zero-initialized.</p>
</blockquote>
<p>Also, the zero initialization sections says</p>
<blockquote>
<p>if T is any other scalar type, the object is initialized to the value
obtained by converting the integer literal 0 (zero) to T;</p>
</blockquote>
<p>So for <code>int</code>, <code>float</code> etc. value initialization means setting to zero. For
example, <code>float x {};</code> explicitly sets <code>x</code> to <code>0</code>. While <code>float x;</code> is default
initialization. How is a primitive default initialized? Section <code>general-7.4</code>
says no initialization is performed, which mean it is random, i.e., any garbage
value at that stack location.</p>
<p>So remember: <strong>scalar type value-initialization is zero-initialization</strong>.</p>
<h3 id="class-type"><a class="header" href="#class-type">Class type</a></h3>
<p>If <code>T</code> is a class type, and if it has a user-provided constructor, then it this
constructor is used. If no such constructor, then it is zero initialized.
<strong>After that, the object is then default initialized.</strong></p>
<p>For example, a simple class as below</p>
<pre><code class="language-cpp">struct A {
  int x, y;
  A(int y): y(y) {}
};

A a(5);
</code></pre>
<p>It has a user-provided constructor. It is first called, so <code>y</code> is initialized
to <code>5</code>. How about <code>x</code>? It is default initialized and thus a random value. If we
change <code>int x, y;</code> to <code>int x = 0; int y;</code>, then it is default to zero.</p>
<p>Let's see another case <code>vecotr&lt;int&gt; v(5);</code>. The vector self is
value-initialized. How about its elements? cppconference.com says "Constructs a
vector with count default-inserted objects of T. No copies are made." What does
<code>default-inserted</code> means? The standard section
<a href="https://eel.is/c++draft/container.requirements#container.alloc.reqmts-2.2">container.requirements#container.alloc.reqmts-2.2</a>
says</p>
<pre><code>An element of X is default-inserted if it is initialized by evaluation of the
expression `allocator_traits&lt;A&gt;::construct(m, p)`.
</code></pre>
<p>I checked the libc++ implementation. The final piece is this
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__memory/construct_at.h#L38">construct_at</a>
function. It basically says</p>
<pre><code>return ::new (static_cast&lt;void*&gt;(__location)) _Tp(std::forward&lt;_Args&gt;(__args)...);
</code></pre>
<p>For this vector example, <code>__args</code> is empty, thus it is simplified to
<code>::new in();</code>. You can test it out<sup class="footnote-reference" id="fr-note1-1"><a href="#footnote-note1">1</a></sup>, this is value initialization!
Therefore, <code>vector&lt;int&gt; v(5);</code> initializes all elements to zero.</p>
<p>Not just for <code>int</code>, it applies to <code>vector&lt;pair&lt;int, int&gt;&gt;</code> and
<code>vector&lt;tuple&lt;int, float&gt;&gt;</code> as well. The default constructor of <code>pair</code> and
<code>tuple</code> both value-initializes all elements. It is explicitly written in
cppconference.com.</p>
<h3 id="array-type"><a class="header" href="#array-type">Array type.</a></h3>
<p>Lastly, if <code>T</code> is an array type, then all its elements are value initialized.
Let's analyze three cases:</p>
<ul>
<li><code>int arr[5];</code>: default initialization. These 5 elements are random.</li>
<li><code>int arr[5] = {};</code>: value initialization. Each element is value initialized.
As said above, each one is zero-initialized. So this is equivalent to
<code>int arr[5] = {0, 0, 0, 0, 0};</code>;</li>
<li><code>int arr[5] = {1, 2};</code>: value initialization.
<a href="https://eel.is/c++draft/dcl.init#general-16.5">dcl.init#general-16.5</a> has a
special paragraph for this case. Basically, element <code>e_i</code> is copy initialized
for <code>1 &lt;= i &lt;= k</code> and remaining elements are value-initialized. so this is
equivalent to <code>int arr[5] = {1, 2, 0, 0, 0};</code>.</li>
</ul>
<h2 id="answers-to-the-questions-at-the-beginning"><a class="header" href="#answers-to-the-questions-at-the-beginning">Answers to the questions at the beginning.</a></h2>
<ol>
<li>No. The elements are random because <code>arr</code> is default initialized.</li>
<li>Yes. All zeros because <code>arr</code> is value initialized.</li>
<li>The first element is <code>1</code>. The rest is <code>0</code>.</li>
<li>Yes. All zeros;</li>
<li>Yes. All pairs have zero first and zero second parts.</li>
</ol>
<hr>
<ol class="footnote-definition"><li id="footnote-note1">
<p>Please do exactly as <code>int *p = new int();</code> because <code>int a();</code> won't give
what you want. Checkout "most vexing parse". <a href="#fr-note1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="comparator"><a class="header" href="#comparator">Comparator</a></h1>
<p><code>std::sort</code> can pass a <code>comp</code> parameter at the end. If not specified, then it
is defaults to
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/sort.h#L967">std::less</a>.</p>
<p>Sometimes, we want to sort nested containers, then how comparison works for
them.</p>
<p>For vector, it is defined as
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__vector/comparison.h#L49">std::lexicographical_compare</a>.
Basically, it compares element by element until a different one is found or one
vector goes out of range. In the latter case, the short vector is smaller.
<code>std:string</code>, <code>std::deque</code>, <code>std::array</code> <code>std::pair</code> and <code>std::tuple</code> are
similar to vector. They compare from the first element. If equal, then the
second, and the rest.</p>
<p><code>std::set</code> and <code>set::map</code> define <code>operator&lt;</code> as well. It is lexicographical
order as well. However, <code>std::unordered_set</code> and <code>std::unordered_map</code> only
define <code>operator==</code> and <code>operator!=</code>.</p>
<p>Comparator is also used extensively in sorted containers. <code>std::set</code> and
<code>std::map</code> has comparator template argument. There is a caveat that</p>
<blockquote>
<p>Everywhere the standard library uses the Compare requirements, uniqueness is
determined by using the equivalence relation. In imprecise terms, two objects
a and b are considered equivalent if neither compares less than the other:
!comp(a, b) &amp;&amp; !comp(b, a).</p>
</blockquote>
<p>The concrete code is
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__tree#L1705">here</a>.
Both <code>set</code> and <code>map</code> are implemented using red-black tree. When inserting a new
element, The case <code>not a &lt; b and not b &lt; a</code> means two keys are equal. If you
forget tie breaker, then you may end up with a undetermined behavior. For
example, in Dijkstra shortest path algorithm, we should define the comparator
as</p>
<pre><code class="language-cpp">auto comp = [&amp;distances](const string &amp;a, const string &amp;b) {
    if (distances[a] != distances[b])
        return distances[a] &lt; distances[b];
    return a &lt; b;
};
</code></pre>
<h1 id="radix-sort"><a class="header" href="#radix-sort">Radix Sort</a></h1>
<p>libc++ has a good demonstration of the usage of radix sort. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/stable_sort.h#L256">code</a>.</p>
<p>First, it is only used if the container value type is integral. It works for
int32, int64, etc but not floats, strings. Also, it supports negative integrals
as well. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/radix_sort.h#L298">code</a>.
Using int8 as an example, the trick <code>numeric_limits&lt;_Ip&gt;::min() ^ value</code> can be
explained by below table.</p>
<pre><code>┌───────────────────┬───────────────────────┬──────────────────────────┬───────────────────┐
│ Original (Signed) │ Binary Representation │ XOR with -128 (10000000) │ Result (Unsigned) │
├───────────────────┼───────────────────────┼──────────────────────────┼───────────────────┤
│ -128              │ 10000000              │ 10000000 ^ 10000000      │ 00000000 (0)      │
│ -127              │ 10000001              │ 10000001 ^ 10000000      │ 00000001 (1)      │
│ -1                │ 11111111              │ 11111111 ^ 10000000      │ 01111111 (127)    │
│ 0                 │ 00000000              │ 00000000 ^ 10000000      │ 10000000 (128)    │
│ 1                 │ 00000001              │ 00000001 ^ 10000000      │ 10000001 (129)    │
│ 127               │ 01111111              │ 01111111 ^ 10000000      │ 11111111 (255)    │
└───────────────────┴───────────────────────┴──────────────────────────┴───────────────────┘
</code></pre>
<p>It maps <code>[-128, 127]</code> to <code>[0, 255]</code> without changing the relative order.</p>
<p>Second, in the competitive coding context, most people will do radix sorting by
comparing the decimal digits, but libc++
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/radix_sort.h#L306">compares bytes</a>.</p>
<p>Third, radix sorting uses counting sort. The basic idea is counting the digit
occurrence and do a prefix sum, so we know the position in the sorted array
given a digit. The caveat is to maintain the stable order. If two numbers have
the same digit, their relative order should not change. The pseudocode is</p>
<pre><code class="language-cpp">void counting_sort(vector&lt;int&gt;&amp; arr, int exp) {
    int n = arr.size();
    vector&lt;int&gt; output(n), count(10, 0);

    // frequency prefix sum.
    for (int i = 0; i &lt; n; i++) count[(arr[i] / exp) % 10]++;
    for (int i = 1; i &lt; 10; i++) count[i] += count[i - 1];

    // start from the right end and decrease the frequency so we can maintain
    // stable order.
    for (int i = n - 1; i &gt;= 0; i--) {
        int digit = (arr[i] / exp) % 10;
        output[count[digit] - 1] = arr[i];
        count[digit]--;
    }
    arr = output;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="priority-queue"><a class="header" href="#priority-queue">Priority Queue</a></h1>
<p>I do not like <code>std::priority_queue</code> because it does not provide the <code>begin</code> nor
<code>end</code> iterator. Later on, I learned a set of functions to deal with max heap
directly: <code>make_heap</code>, <code>push_heap</code> and <code>pop_heap</code>. I am very happy with it
because it allows me implementing priority queue on top of vector, and I can
iterate vector! Then I suspect the push/pop operation of <code>std::priority_queue</code>
is just a wrapper of <code>push_heap</code>/<code>pop_heap</code>. It is! See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/queue#L899">code</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-vs-graph"><a class="header" href="#tree-vs-graph">Tree vs Graph</a></h1>
<p>A tree is an undirected, connected, and acyclic graph. It has <code>n</code> nodes, <code>n-1</code>
edges and is fully connected. This setup often shows up in competitive
programming.</p>
<p>Realizing it is a tree is helpful for DFS because often times the graph
definition contains not only the child nodes but also the parent node. A simple
trick to skip going back is</p>
<pre><code class="language-cpp">for (next : graph[node]):
    if (next == parent_node) continue
</code></pre>
<h1 id="segment-tree"><a class="header" href="#segment-tree">Segment Tree</a></h1>
<p>A few conventions to reduce chances of mistakes.</p>
<ol>
<li>left branch is <code>[l, m]</code>, right branch is <code>[m+1, r]</code>. This avoids the index
of out of range error for the middle point <code>(l+r)/2</code>.</li>
</ol>
<p>Below is the naive implementation using explicit tree node.</p>
<details class="code-details">
<summary> struct Node; </summary>
<pre><code class="language-cpp">struct Node {
    int l, r;
    shared_ptr&lt;Node&gt; left, right;
    int s; // each node stores the sum of the range [l,r].
    Node(int l, int r): l(l), r(r), s(0) {}
};
using NodeP = shared_ptr&lt;Node&gt;;

NodeP root;

void create_children(NodeP node) {
     if (node-&gt;l != node-&gt;r) {
        int m = (node-&gt;l + node-&gt;r) / 2;
        if (not node-&gt;left) node-&gt;left = make_shared&lt;Node&gt;(node-&gt;l, m);
        if (not node-&gt;right) node-&gt;right = make_shared&lt;Node&gt;(m+1, node-&gt;r);
    }
}

int query(NodeP node, int l, int r) {
    int m = (node-&gt;l + node-&gt;r) / 2;
    create_children(node);
    if (node-&gt;l == l and node-&gt;r == r) {
        return node-&gt;s;
    }

    if (r &lt;= m) return search(node-&gt;left, l, r);
    else if (l &gt; m) return search(node-&gt;right, l, r);
    else return search(node-&gt;left, l, m) + search(node-&gt;right, m+1, r);
}

// Add val to the existing value at node i.
void update(NodeP node, int i, int val) {
  create_children();
  node-&gt;s += val;
  if (node-&gt;l == i and node-&gt;r == i) return;
  int m = (node-&gt;l + node-&gt;r) / 2;
  if (i &lt;= m) update(node-&gt;left, i, val);
  else update(node-&gt;right, i, val);
}
</code></pre>
</details>
<p>Most segment tree code you see online uses an array to represent the tree. See
<a href="https://www.hackerearth.com/practice/notes/segment-tree-and-lazy-propagation/">example</a>.
An array <code>int tree[2n+1]</code> represent a tree with <code>n</code> nodes. <code>tree[k]</code> has
children <code>tree[2k]</code> and <code>tree[2k+1]</code>. Root node is <code>tree[1]</code>. However, I do not
like this implementation because it makes the interface more verbose. In my
implementation, <code>struct Node</code> contains the boundary information <code>l</code> and <code>r</code>.
With the array approach, the interface becomes
<code>int query(int node, int start, int end, int l, int r)</code>. The first 3 parameters
are the node index, left and right boundary.</p>
<h2 id="lazy-propagation"><a class="header" href="#lazy-propagation">Lazy Propagation</a></h2>
<p>The basic search and update operation has <code>O(logN)</code> complexity. It is not
efficient for range update. To make it <code>O(logN)</code> as well, we need lazy
propagation. A new helper <code>push</code> introduced. It realized the laziness at the
current node, and push the laziness down to its children. There are four places
we need <code>push</code>. First, at the beginning of a query, which is obvious. Then 3
places in <code>update</code>:</p>
<ol>
<li>At the beginning of <code>update</code>.</li>
<li>At the base condition, i.e., query range equals node's boundary. This is
where the performance improvement comes from. It avoids going deep to leaf
nodes, and simply put a marker in the current node saying: all nodes under
this subtree have an un-realized update amount <code>inc_amount</code>.</li>
<li>Before we finally update current node's value. This is pre-order traversal.
We need to make sure the left and right children do not have any lazy value
before we add them up. Otherwise, it would be wrong. This is most popular
mistake I made!</li>
</ol>
<details class="code-details">
<summary> Lazy Propagation </summary>
<pre><code class="language-cpp">struct Node {
    int l, r;
    shared_ptr&lt;Node&gt; left, right;
    int lazy = 0; // lazy update amount
    int s;
    Node(int l, int r): l(l), r(r), s(0) {}
};
using NodeP = shared_ptr&lt;Node&gt;;

NodeP root;

void create_children(NodeP node) {
     if (node-&gt;l != node-&gt;r) {
        int m = (node-&gt;l + node-&gt;r) / 2;
        if (not node-&gt;left) node-&gt;left = make_shared&lt;Node&gt;(node-&gt;l, m);
        if (not node-&gt;right) node-&gt;right = make_shared&lt;Node&gt;(m+1, node-&gt;r);
    }
}

// realize laziness at current node and push it down the tree.
void push(NodeP node) {
    if (node-&gt;lazy) {
        node-&gt;s += node-&gt;lazy * (node-&gt;r - node-&gt;l + 1);
        // only push down when it is not a leaf node.
        if (node-&gt;l != node-&gt;r) {
            node-&gt;left-&gt;lazy += node-&gt;lazy;
            node-&gt;right-&gt;lazy += node-&gt;lazy;
        }
        // remember to reset laziness.
        node-&gt;lazy = 0;
    }
}

int query(NodeP node, int l, int r) {
    int m = (node-&gt;l + node-&gt;r) / 2;
    create_children(node);
    // realize laziness before query.
    push(node);
    if (node-&gt;l == l and node-&gt;r == r) {
        return node-&gt;s;
    }

    if (r &lt;= m) return search(node-&gt;left, l, r);
    else if (l &gt; m) return search(node-&gt;right, l, r);
    else return search(node-&gt;left, l, m) + search(node-&gt;right, m+1, r);
}

void update(NodeP node, int l, int r, int inc_amount) {
    int m = (node-&gt;l + node-&gt;r) / 2;
    create_children(node);
    push(node);

    if (node-&gt;l == l and node-&gt;r == r) {
        node-&gt;lazy += inc_amount;
        push(node);
        return;
    }
    if (r &lt;= m) {
        insert(node-&gt;left, l, r);
    } else if (l &gt; m) {
        insert(node-&gt;right, l, r);
    } else {
        insert(node-&gt;left, l, m);
        insert(node-&gt;right, m+1, r);
    }
    // make sure left and right do not have un-realized updates.
    push(node-&gt;left); push(node-&gt;right);
    node-&gt;s = node-&gt;left-&gt;s + node-&gt;right-&gt;s;
}
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lower_bound-and-upper_bound"><a class="header" href="#lower_bound-and-upper_bound">lower_bound and upper_bound</a></h1>
<p>These two functions/interfaces are very counter intuitive the first time I read
it. <code>lower_bound</code> means the position that is greater or equal than the target.
<code>upper_bound</code> means the position that is greater than the target. Actually,
<code>bound</code> means boundary. I should understand it as the half-open <strong>equal-range
boundaries</strong> <code>[lower_bound, upper_bound)</code>. Within this range, all elements are
equal to the target.</p>
<p>We have <code>std::lower_bound</code> and <code>map::lower_bound</code>. What are the differences?
The former is implemented
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/lower_bound.h#L30">here</a>.
The latter is implemented
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__tree#L2156">here</a>.</p>
<p><code>std::lower_bound</code> only requires <code>ForwardIterator</code>. The time complexity is
<code>O(logN)</code> for <code>RandomAccessIterator</code> but <code>O(NlogN)</code> for non random access
iterators because it uses <code>std::advance</code>. On the other hand, <code>map::lower_bound</code>
bisects to the left or right branch, so it is always <code>O(logN)</code>.</p>
<p><code>std::binary_search</code> is just a wrapper of <code>std::lower_bound</code>. See
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/binary_search.h#L27">code</a>.
It returns <code>__first != __last &amp;&amp; !__comp(__value, *__first)</code>, i.e., a boolean
whether the target is found or not.</p>
<h2 id="meta-binary-search"><a class="header" href="#meta-binary-search">Meta binary search</a></h2>
<p>One interesting thing I learnt from reading libc++ code is
<a href="https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/libcxx/include/__algorithm/lower_bound.h#L61">meta binary search</a>.
The idea is very similar to radix sort. You try out index <code>1xxxxx</code> first. If
the value at index <code>100...0</code> is larger than the target, then you to <code>0xxxxx</code>.
Otherwise, you go to the second significant bit <code>11xxxx</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kmp-knuthmorrispratt"><a class="header" href="#kmp-knuthmorrispratt">KMP (Knuth–Morris–Pratt)</a></h2>
<p>Given a long string S (text) and a short string W (pattern), find all positions
in S such that the substring starting from that position equals W. Let
<code>n = len(S)</code> and <code>m = len(W)</code>, then the brute-force solution has time
complexity <code>O(n*m)</code>.</p>
<h3 id="intuition"><a class="header" href="#intuition">Intuition</a></h3>
<p>Key points:</p>
<ol>
<li>
<p>Construct <code>lps</code> : longest proper prefix which is also a suffix.</p>
<p><code>lps[i]</code> = the longest proper prefix of <code>W[0..i]</code> which is also a suffix of
<code>W[0..i]</code>. proper prefix means it is prefix but not equal to itself.</p>
</li>
<li>
<p>The mismatched position is the crucial part.</p>
</li>
</ol>
<p>Let's simulation a case.</p>
<pre><code>i = current compare pos of S
j = current compare pos of W

01234567[8]90123456789012345 =&gt; S
    0123[4]56                =&gt; W
</code></pre>
<p>Above i = 8, j = 4, and we find <code>S[i] != W[j]</code>. What should we do?</p>
<p>For brute-force method, we simply shift W to right by one space and compare
from start again, namely,</p>
<pre><code>reset i = 5, j = 0.

01234[5]67890123456789012345 =&gt; S
     [0]123456               =&gt; W
</code></pre>
<p>Same for KMP, we need shift W to right, but the question is could we shift more
than one space? In this case, we already know that <code>S[4:7] = W[0:3]</code>. The
crucial part is that we should find a character in <code>W[0..x]</code> to compare <code>S[8]</code>.
We must have <code>x &lt; 4</code> since we will shift W to right. (Please think about this
part!) Suppose <code>x = 2</code></p>
<pre><code>01234567[8]90123456789012345 =&gt; S
      01[2]3456              =&gt; W
</code></pre>
<p>This configuration also means that <code>S[6:7]</code> = <code>W[0:1]</code>, but from about
<code>S[4:7] = W[0:3]</code>. So, we have <code>S[6:7] = W[0:1] = W[2:3]</code>, that is
<code>prefix = suffix</code>. In order to be conservative and not miss any possible
solution, we need x to be as large as possible, that is we need to find largest
proper <code>prefix = suffix</code>. That is <code>lps[i]</code>. Please draw the relation on a piece
of paper!</p>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<p>Below Implementation is generated by Claude.ai. I explicitly ask him to make it
memorable. The key insight is that <strong>the same pattern works for both building
the LPS array and searching</strong>.</p>
<pre><code class="language-cpp">vector&lt;int&gt; kmp(const string&amp; text, const string&amp; pattern) {
    /******** Build LPS ********/
    int m = pattern.size();
    vector&lt;int&gt; lps(m);
    lsp[0] = 0; // why zero? Because it is proper prefix.

    // we start with i = 1, and in each iteration we guarantee to find lps[i].
    for (int i = 1, j=0; i &lt; m; i++) {
        // we the current character does not match, we move j to the last
        // longest proper prefix because the characters before that are guaranteed
        // to match and the move is conservative.
        while (j &gt; 0 &amp;&amp; pattern[i] != pattern[j]) j = lps[j - 1];

        // after the above loop, there are two possible outcome.
        // 1. pattern[i] == pattern[j] and j &gt;= 0. Note j could be zero in this case.
        // 2. pattern[i] != pattern[j] and j = 0. This case much have j = 0.
        if (pattern[i] == pattern[j]) j++;

        // for case #1, lsp[i] = (j - 0 + 1), but since we have j++ step above,
        // it becomes lsp[i] = j.
        // for case #2, j = 0, so lsp[i] = j = 0;
        lps[i] = j;
    }

    /******** Search ********/
    vector&lt;int&gt; matches;
    // For search, we start i, j both from zero.
    for (int i = 0, j = 0; i &lt; text.size(); i++) {
        while (j &gt; 0 &amp;&amp; text[i] != pattern[j]) j = lps[j - 1];
        if (text[i] == pattern[j]) j++;

        // when j==m, index of W goes out of range [0..m-1]
        // We can think of W[m] exits but definitely does not equal to S[i],
        // then we need assign j = lps[j-1].
        if (j == m) {
            matches.push_back(i - m + 1); // S[i-m+1, i] matches W.
            j = lps[j - 1];
        }
    }
    return matches;
}
</code></pre>
<p>The same pattern is as below.</p>
<pre><code>while j &gt; 0 and mismatch:
    j = lps[j - 1]
if match:
    j += 1
</code></pre>
<p>Memorization Tips:</p>
<ul>
<li>Two phases: Build LPS array, then search (same logic for both!).</li>
<li>Two pointers: <code>i</code> goes through text/pattern, <code>j</code> tracks match length.</li>
<li>On mismatch: Jump back using <code>j = lps[j - 1]</code> (keep doing this while
<code>j &gt; 0</code>).</li>
<li>On match: Just increment <code>j</code>.</li>
<li>Full match: When <code>j == len(pattern)</code>, you found it!</li>
</ul>
<p>What makes it "simple":</p>
<ul>
<li>No complex cases to handle.</li>
<li>The LPS building and searching use almost identical code.</li>
<li>Just ~15 lines of actual logic.</li>
</ul>
<h4 id="trick"><a class="header" href="#trick">Trick</a></h4>
<p>As you see above, the two stages are almost the same. We can have a trick to
write fewer lines of code. Suppose there is a character such as <code>$</code> that does
not show up in either the text corps nor the pattern, then we can create a new
string <code>{pattern}${text}</code> and build LPS for it. What does the result mean?</p>
<ol>
<li>The prefix is <code>{pattern}$</code>, and <code>$</code> does not show up anywhere else. This
means <code>lps[i] &lt;= len(pattern)</code>.</li>
<li>If <code>lps[i] == len(pattern)</code>, then <code>s[i-len(pattern)+1..i]</code> matches pattern.
So we just iterate <code>lps</code> to find all indices. Note, because we prefixed
<code>len(pattern) + 1</code> to the original string, then correct substring range
should be <code>s[i-len(patthern)-1-len(pattern)+1..i-len(pattern)-1]</code>, which is
<code>s[i-2*len(pattern)..i-len(pattern)-1]</code></li>
</ol>
<pre><code class="language-cpp">vector&lt;int&gt; kmp(const string&amp; s, const string&amp; p) {
  string s2 = p + "$" + s;
  int n = s2.size();
  vector&lt;int&gt; lps(n);
  for (int i = 1, j = 0; i &lt; n; i++) {
    while (j &gt; 0 and s2[i] != s2[j]) j = lps[j-1];
    if (s2[i] == s2[j]) j++;
    lps[i] = j;
  }
  vector&lt;int&gt; matches;
  for (int i = 0; i &lt; n; i++) {
    if (lps[i] == p.size()) matches.push_back(i - 2*p.size());
  }
  return matches;
}
</code></pre>
<h3 id="complexity"><a class="header" href="#complexity">Complexity</a></h3>
<ul>
<li>time complexity: <code>O(n+m)</code>.</li>
<li>space complexity <code>O(m)</code>.</li>
</ul>
<p>We all agree that <code>i</code> increases exactly by one in each outer loop iteration.
But <code>j</code> can move forward and backward inside the inner loop. So why complexity
is <code>O(n+m)</code> but not <code>O(n*m)</code>? We need amortized analysis.</p>
<ul>
<li><code>j</code> can increase by at most 1 per iteration.</li>
<li><code>j</code> starts at 0, max value is m.</li>
<li>Total increases: at most n.</li>
<li>Total decreases: at most n (can't decrease more than it increased!).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boyermoore"><a class="header" href="#boyermoore">Boyer–Moore</a></h1>
<p>This is also a string matching algorithm. It has sublinear time complexity for
regular cases, but worse <code>O(n*m)</code> complexity, so it is frequently used in
practice, but not good for competitive programming. By the way, C++ 17 and
above has std implementation for Boyer-Moore search algorithm.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="z-algorithm"><a class="header" href="#z-algorithm">Z algorithm</a></h1>
<p>The Z-function (or Z-algorithm) is a string processing algorithm that computes,
for each position in a string, the length of the longest substring starting at
that position which is also a prefix of the string. Given a string <code>s</code> of
length <code>n</code>, the Z-function of <code>s</code> is an array <code>Z</code> of length n where:</p>
<pre><code>Z[i] = max k such that s[0..k-1] == s[i..i+k-1]
</code></pre>
<p>This reminds me about the longest proper prefix suffix array in KMP.</p>
<p>I send below prompt to claude.ai.</p>
<blockquote>
<p>could you do an animation of z-algorithm with details about the definitions
of Z box and how it is updated?</p>
</blockquote>
<p>And it generated beautiful animation and detailed explanation. Below content is
mostly copied from claude. It summarizes better than me.</p>
<h2 id="what-is-the-z-box-l-r"><a class="header" href="#what-is-the-z-box-l-r">What is the Z-Box [L, R]?</a></h2>
<p>The Z-box is an interval <code>[L, R]</code> representing the <strong>rightmost</strong> segment of the
string where:</p>
<ul>
<li><code>s[L..R]</code> exactly matches <code>s[0..R-L]</code> (a prefix of the string).</li>
<li><code>R</code> is as large as possible (rightmost such segment we've found).</li>
<li>It helps us avoid redundant character comparisons.</li>
</ul>
<p>Two Main Cases:</p>
<ul>
<li>
<p>Case 1: <code>i &gt; R</code> (Outside the Z-box)</p>
<p>Position i is beyond our known matching segment. We must compare characters
from scratch to compute <code>Z[i]</code>, then update the Z-box to <code>[i, i+Z[i]-1]</code>.</p>
</li>
<li>
<p>Case 2: <code>i ≤ R</code> (Inside the Z-box)</p>
<p>Position i falls within <code>[L, R]</code>. We use the "mirror" position <code>k = i - L</code>.
Since <code>s[L..R]</code> matches <code>s[0..R-L]</code>, we know <code>s[i..R]</code> corresponds to
<code>s[k..R-L]</code>.</p>
<ul>
<li>
<p>Case 2a: <code>Z[k] &lt; r - i + 1</code></p>
<p>The match at k is fully contained. Simply copy: <code>Z[i] = Z[k]</code>. Z-box
unchanged.</p>
</li>
<li>
<p>Case 2b: <code>Z[k] ≥ r - i + 1</code></p>
<p>The match might extend beyond <code>R</code>. We know it matches up to <code>R</code>, but must
compare beyond to see how far it extends. Update Z-box to <code>[i, new_R]</code>.</p>
</li>
</ul>
</li>
</ul>
<p>The core intuition of Z algorithm is "rightmost"! There are a few invariants.
When we process index <code>i</code>, we must have <code>i &gt; L</code>, and <code>R &gt;= L - 1</code>. The
<code>R == L - 1</code> case corresponds to Z value being 0. Remember we use a close range
<code>[L, R]</code>.</p>
<h2 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h2>
<pre><code class="language-cpp">vector&lt;int&gt; compute_z_array(const string&amp; s) {
  int n = s.size();
  vector&lt;int&gt; Z(n); // Z[0] = 0 by tradition.

  int l = 0, r = 0; // Z-box [l, r]
  for (int i = 1; i &lt; n; i++) {
    if (i &gt; r) { // case 1.
      l = r = i;
      int tmp = 0;
      while (r &lt; n and s[r] == s[tmp++]) r++;
      Z[i] = --r - l + 1; // we need --r because it goes one index beyond.
    } else { // case 2.
      // s[i..r] == s[i-l, r-l] == s[k, r-l]
      int k = i - l;
      if (Z[k] &lt; r-i+1) Z[i] = Z[k];
      else {
        // in this case, we find a even more right range staring at i,
        // and s[i..r] == s[0, r-i], and there is potential to extend it.
        l = i;
        // node predefine tmp to r-i avoids bugs because below code updates r.
        int tmp = r-i;
        while (r &lt; n and s[r] == s[tmp++]) r++;
        Z[i] = --r - l + 1;
      }
    }
  }
  return Z;
}
</code></pre>
<h2 id="complexity-1"><a class="header" href="#complexity-1">Complexity</a></h2>
<ul>
<li>time complexity: <code>O(n)</code>. The Z-box boundary R only moves to the right (never
left). Each character comparison either increases R or we're done with that
position. Since R can increase at most n times, total comparisons = <code>O(n)</code>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
