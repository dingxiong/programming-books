## KMP (Knuth–Morris–Pratt)

Given a long string S (text) and a short string W (pattern), find all positions
in S such that the substring starting from that position equals W. Let
`n = len(S)` and `m = len(W)`, then the brute-force solution has time
complexity `O(n*m)`.

### Intuition

Key points:

1. Construct `lps` : longest proper prefix which is also a suffix.

   `lps[i]` = the longest proper prefix of `W[0..i]` which is also a suffix of
   `W[0..i]`. proper prefix means it is prefix but not equal to itself.

2. The mismatched position is the crucial part.

Let's simulation a case.

```
i = current compare pos of S
j = current compare pos of W

01234567[8]90123456789012345 => S
    0123[4]56                => W
```

Above i = 8, j = 4, and we find `S[i] != W[j]`. What should we do?

For brute-force method, we simply shift W to right by one space and compare
from start again, namely,

```
reset i = 5, j = 0.

01234[5]67890123456789012345 => S
     [0]123456               => W
```

Same for KMP, we need shift W to right, but the question is could we shift more
than one space? In this case, we already know that `S[4:7] = W[0:3]`. The
crucial part is that we should find a character in `W[0..x]` to compare `S[8]`.
We must have `x < 4` since we will shift W to right. (Please think about this
part!) Suppose `x = 2`

```
01234567[8]90123456789012345 => S
      01[2]3456              => W
```

This configuration also means that `S[6:7]` = `W[0:1]`, but from about
`S[4:7] = W[0:3]`. So, we have `S[6:7] = W[0:1] = W[2:3]`, that is
`prefix = suffix`. In order to be conservative and not miss any possible
solution, we need x to be as large as possible, that is we need to find largest
proper `prefix = suffix`. That is `lps[i]`. Please draw the relation on a piece
of paper!

### Implementation

Below Implementation is generated by Claude.ai. I explicitly ask him to make it
memorable. The key insight is that **the same pattern works for both building
the LPS array and searching**.

```cpp
vector<int> kmp(const string& text, const string& pattern) {
    /******** Build LPS ********/
    int m = pattern.size();
    vector<int> lps(m);
    lsp[0] = 0; // why zero? Because it is proper prefix.

    // we start with i = 1, and in each iteration we guarantee to find lps[i].
    for (int i = 1, j=0; i < m; i++) {
        // we the current character does not match, we move j to the last
        // longest proper prefix because the characters before that are guaranteed
        // to match and the move is conservative.
        while (j > 0 && pattern[i] != pattern[j])
            j = lps[j - 1];

        // after the above loop, there are two possible outcome.
        // 1. pattern[i] == pattern[j] and j >= 0. Note j could be zero in this case.
        // 2. pattern[i] != pattern[j] and j = 0. This case much have j = 0.
        if (pattern[i] == pattern[j])
            j++;

        // for case #1, lsp[i] = (j - 0 + 1), but since we have j++ step above,
        // it becomes lsp[i] = j.
        // for case #2, j = 0, so lsp[i] = j = 0;
        lps[i] = j;
    }

    /******** Search ********/
    vector<int> matches;
    // For search, we start i, j both from zero.
    for (int i = 0, j = 0; i < text.size(); i++) {
        while (j > 0 && text[i] != pattern[j])
            j = lps[j - 1];
        if (text[i] == pattern[j])
            j++;

        // when j==m, index of W goes out of range [0..m-1]
        // We can think of W[m] exits but definitely does not equal to S[i],
        // then we need assign j = lps[j-1].
        if (j == m) {
            matches.push_back(i - m + 1); // S[i-m+1, i] matches W.
            j = lps[j - 1];
        }
    }
    return matches;
}
```

The same pattern is as below.

```
while j > 0 and mismatch:
    j = lps[j - 1]
if match:
    j += 1
```

Memorization Tips:

- Two phases: Build LPS array, then search (same logic for both!).
- Two pointers: `i` goes through text/pattern, `j` tracks match length.
- On mismatch: Jump back using `j = lps[j - 1]` (keep doing this while
  `j > 0`).
- On match: Just increment `j`.
- Full match: When `j == len(pattern)`, you found it!

What makes it "simple":

- No complex cases to handle.
- The LPS building and searching use almost identical code.
- Just ~15 lines of actual logic.

### Complexity

- time complexity: `O(n+m)`.
- space complexity `O(m)`.

We all agree that `i` increases exactly by one in each outer loop iteration.
But `j` can move forward and backward inside the inner loop. So why complexity
is `O(n+m)` but not `O(n*m)`? We need amortized analysis.

- `j` can increase by at most 1 per iteration.
- `j` starts at 0, max value is m.
- Total increases: at most n.
- Total decreases: at most n (can't decrease more than it increased!).
